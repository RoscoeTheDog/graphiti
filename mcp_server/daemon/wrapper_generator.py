"""
Graphiti Wrapper Generator

Generates platform-specific CLI wrapper scripts that invoke the venv Python
without requiring activation.

This module provides:
- Platform-specific wrapper script generation (Windows .cmd, Unix shell)
- Automatic bin directory creation (~/.graphiti/bin/)
- Absolute path handling to venv Python
- Executable permissions on Unix scripts
- Validation of generated wrappers

Design Principle: Wrapper scripts enable direct CLI invocation by absolute path,
supporting PATH integration without activation overhead.

See: .claude/sprint/stories/3-cli-wrapper-script-generation.md
"""

import logging
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)


class WrapperGenerationError(Exception):
    """Raised when wrapper generation fails."""
    pass


class WrapperGenerator:
    """Manager for generating platform-specific wrapper scripts."""

    # Commands to generate wrappers for (name -> module path)
    COMMANDS: Dict[str, str] = {
        "graphiti-mcp": "mcp_server.graphiti_mcp_server",
        "graphiti-bootstrap": "mcp_server.daemon.bootstrap",
        "graphiti-mcp-daemon": "mcp_server.daemon.manager",
    }

    def __init__(self, venv_path: Optional[Path] = None, bin_path: Optional[Path] = None):
        """
        Initialize WrapperGenerator.

        Args:
            venv_path: Path to venv directory. Defaults to ~/.graphiti/.venv/
            bin_path: Path to bin directory. Defaults to ~/.graphiti/bin/
        """
        if venv_path is None:
            venv_path = Path.home() / ".graphiti" / ".venv"
        if bin_path is None:
            bin_path = Path.home() / ".graphiti" / "bin"

        self.venv_path = venv_path
        self.bin_path = bin_path

    def get_python_path(self) -> Path:
        """
        Get absolute path to Python executable in venv.

        Returns:
            Path to python executable

        Raises:
            WrapperGenerationError: If venv does not exist
        """
        if not self.venv_path.exists():
            raise WrapperGenerationError(
                f"Venv does not exist at {self.venv_path}. "
                "Create venv before generating wrappers."
            )

        if sys.platform == "win32":
            python_exe = self.venv_path / "Scripts" / "python.exe"
        else:
            python_exe = self.venv_path / "bin" / "python"

        if not python_exe.exists():
            raise WrapperGenerationError(
                f"Python executable not found in venv: {python_exe}"
            )

        return python_exe

    def create_bin_directory(self) -> None:
        """
        Create ~/.graphiti/bin/ directory if it doesn't exist.

        Idempotent: safe to call multiple times.

        Raises:
            WrapperGenerationError: If directory creation fails
        """
        try:
            self.bin_path.mkdir(parents=True, exist_ok=True)
            logger.debug(f"Bin directory ready: {self.bin_path}")
        except Exception as e:
            raise WrapperGenerationError(
                f"Failed to create bin directory {self.bin_path}: {e}\n"
                "Check write permissions to ~/.graphiti/"
            )

    def generate_windows_wrapper(
        self, command_name: str, module_path: str, python_path: Path
    ) -> Path:
        """
        Generate Windows .cmd batch wrapper script.

        Args:
            command_name: Name of command (e.g., "graphiti-mcp")
            module_path: Python module to invoke (e.g., "mcp_server.graphiti_mcp_server")
            python_path: Absolute path to venv Python

        Returns:
            Path to generated .cmd file

        Raises:
            WrapperGenerationError: If wrapper generation fails
        """
        wrapper_path = self.bin_path / f"{command_name}.cmd"

        # Windows batch template
        template = f"""@echo off
REM Graphiti {command_name} wrapper
REM Auto-generated by graphiti-mcp daemon install
"{python_path}" -m {module_path} %*
"""

        try:
            wrapper_path.write_text(template, encoding="utf-8")
            logger.debug(f"Generated Windows wrapper: {wrapper_path}")
            return wrapper_path
        except Exception as e:
            raise WrapperGenerationError(
                f"Failed to write Windows wrapper {wrapper_path}: {e}\n"
                "Check disk space and write permissions"
            )

    def generate_unix_wrapper(
        self, command_name: str, module_path: str, python_path: Path
    ) -> Path:
        """
        Generate Unix shell script wrapper with executable permissions.

        Args:
            command_name: Name of command (e.g., "graphiti-mcp")
            module_path: Python module to invoke (e.g., "mcp_server.graphiti_mcp_server")
            python_path: Absolute path to venv Python

        Returns:
            Path to generated shell script

        Raises:
            WrapperGenerationError: If wrapper generation fails
        """
        wrapper_path = self.bin_path / command_name

        # Unix shell template
        template = f"""#!/bin/bash
# Graphiti {command_name} wrapper
# Auto-generated by graphiti-mcp daemon install
"{python_path}" -m {module_path} "$@"
"""

        try:
            wrapper_path.write_text(template, encoding="utf-8")
            logger.debug(f"Generated Unix wrapper: {wrapper_path}")

            # Set executable permissions (0o755 = rwxr-xr-x)
            try:
                os.chmod(wrapper_path, 0o755)
                logger.debug(f"Set executable permissions: {wrapper_path}")
            except Exception as e:
                # Warn but don't fail - script may still work
                logger.warning(
                    f"Failed to set executable permissions on {wrapper_path}: {e}\n"
                    "You may need to run: chmod +x {wrapper_path}"
                )

            return wrapper_path
        except Exception as e:
            raise WrapperGenerationError(
                f"Failed to write Unix wrapper {wrapper_path}: {e}\n"
                "Check disk space and write permissions"
            )

    def generate_wrappers(self) -> Tuple[bool, str]:
        """
        Generate all wrapper scripts for configured commands.

        Creates platform-specific wrappers for:
        - graphiti-mcp
        - graphiti-bootstrap
        - graphiti-mcp-daemon

        Returns:
            Tuple of (success: bool, message: str)

        Raises:
            WrapperGenerationError: If wrapper generation fails critically
        """
        try:
            # Validate venv exists
            python_path = self.get_python_path()
            logger.info(f"Using venv Python: {python_path}")

            # Create bin directory
            self.create_bin_directory()

            # Generate wrappers for each command
            generated: List[Path] = []
            for command_name, module_path in self.COMMANDS.items():
                if sys.platform == "win32":
                    wrapper_path = self.generate_windows_wrapper(
                        command_name, module_path, python_path
                    )
                else:
                    wrapper_path = self.generate_unix_wrapper(
                        command_name, module_path, python_path
                    )
                generated.append(wrapper_path)

            # Validate all wrappers exist
            for wrapper_path in generated:
                if not wrapper_path.exists():
                    raise WrapperGenerationError(
                        f"Wrapper generation succeeded but file not found: {wrapper_path}"
                    )

            msg = (
                f"Successfully generated {len(generated)} wrapper scripts in {self.bin_path}\n"
                f"Commands: {', '.join(self.COMMANDS.keys())}"
            )
            logger.info(msg)
            return True, msg

        except WrapperGenerationError as e:
            error_msg = f"Wrapper generation failed: {e}"
            logger.error(error_msg)
            return False, error_msg
        except Exception as e:
            error_msg = f"Unexpected error during wrapper generation: {e}"
            logger.error(error_msg)
            return False, error_msg

    def validate_wrappers(self) -> Tuple[bool, str]:
        """
        Validate that all wrapper scripts exist.

        Returns:
            Tuple of (all_exist: bool, message: str)
        """
        if not self.bin_path.exists():
            msg = f"Bin directory does not exist: {self.bin_path}"
            logger.warning(msg)
            return False, msg

        missing: List[str] = []
        for command_name in self.COMMANDS.keys():
            if sys.platform == "win32":
                wrapper_path = self.bin_path / f"{command_name}.cmd"
            else:
                wrapper_path = self.bin_path / command_name

            if not wrapper_path.exists():
                missing.append(str(wrapper_path))

        if missing:
            msg = f"Missing wrapper scripts: {', '.join(missing)}"
            logger.warning(msg)
            return False, msg

        msg = f"All {len(self.COMMANDS)} wrapper scripts exist"
        logger.debug(msg)
        return True, msg

    def cleanup_wrappers(self) -> Tuple[bool, str]:
        """
        Remove all generated wrapper scripts.

        Returns:
            Tuple of (success: bool, message: str)
        """
        if not self.bin_path.exists():
            msg = f"Bin directory does not exist: {self.bin_path} (nothing to clean)"
            logger.info(msg)
            return True, msg

        removed: List[Path] = []
        for command_name in self.COMMANDS.keys():
            if sys.platform == "win32":
                wrapper_path = self.bin_path / f"{command_name}.cmd"
            else:
                wrapper_path = self.bin_path / command_name

            if wrapper_path.exists():
                try:
                    wrapper_path.unlink()
                    removed.append(wrapper_path)
                    logger.debug(f"Removed wrapper: {wrapper_path}")
                except Exception as e:
                    logger.warning(f"Failed to remove wrapper {wrapper_path}: {e}")

        msg = f"Removed {len(removed)} wrapper scripts"
        logger.info(msg)
        return True, msg
