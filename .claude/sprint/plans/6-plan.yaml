# Plan: 6
# Generated by: discovery:6.d
# Timestamp: 2025-12-20T20:35:00Z

story_id: "6"
title: "Remediation Testing Trigger"
created: "2025-12-20T20:35:00Z"
created_by: "discovery:6.d"

# Analysis Summary
analysis:
  summary: "Update execute-testing.md helper to trigger reconciliation when remediation.t completes successfully. Detect remediation story type, calculate test overlap with blocked validation, apply appropriate reconciliation mode, and report result to user."
  complexity: "medium"
  estimated_files: 1
  estimated_tokens: 12000
  risk_factors:
    - "Integration point with existing testing phase handler (execute-testing.md)"
    - "Must detect remediation story type correctly (parent starts with 'R' or contains '.r.')"
    - "Blocked validation detection requires finding original validation from remediation metadata"
    - "User messaging must be clear and actionable (explain reconciliation outcome)"
    - "Edge cases: remediation without blocked validation, multiple blocked validations"

# Files to Modify
files_to_modify:
  - path: "resources/commands/sprint/helpers/execute-testing.md"
    changes:
      - "Add STEP 14: Trigger Reconciliation (After STEP 13 completion announcement)"
      - "Detect remediation story type from parent ID pattern"
      - "Extract original validation ID from remediation metadata (test_reconciliation.original_story_id)"
      - "Find blocked validation story using original_story_id + '.t' pattern"
      - "Load test results from both remediation and original validation"
      - "Call calculate_test_overlap() to determine overlap percentage"
      - "Call determine_reconciliation_mode() to get mode (propagate/retest/supersede)"
      - "Apply reconciliation using appropriate function (apply_propagate_reconciliation, etc.)"
      - "Announce reconciliation result to user with clear status message"
    lines_affected: 80
    rationale: "Testing phase is completion point for remediation.t - natural integration point"

# Integration Points
integration_points:
  testing_phase_handler:
    file: "resources/commands/sprint/helpers/execute-testing.md"
    current_flow: |
      STEP 1-7: Load requirements, write/run tests
      STEP 8: Calculate pass rate
      STEP 9: Generate test results artifact
      STEP 10: Create advisory
      STEP 11: Update queue state
      STEP 12: Commit changes
      STEP 13: Announce completion
    new_step: |
      STEP 14: Trigger Reconciliation (NEW)
        - Applies ONLY to remediation.t stories
        - Runs AFTER successful test completion (pass_rate >= 90%)
        - Reports reconciliation outcome to user

  reconciliation_functions:
    file: "resources/commands/sprint/queue_helpers/reconciliation.py"
    functions_used:
      - apply_propagate_reconciliation(target_validation_id, source_remediation_id, test_results, sprint_dir)
      - apply_retest_reconciliation(target_validation_id, source_remediation_id, test_results, retest_reason, sprint_dir)
      - apply_supersede_reconciliation(target_validation_id, source_remediation_id, test_results, supersession_reason, sprint_dir)
    return_format: |
      {
        "status": "success|error|skipped",
        "mode": "propagate|retest|supersede",
        "target": "validation_id",
        "source": "remediation_id",
        "message": "Human-readable message",
        "updated_stories": ["list", "of", "updated", "story", "ids"]
      }

  overlap_calculation:
    file: "resources/commands/sprint/queue_helpers/overlap.py"
    functions_used:
      - calculate_test_overlap(remediation_tests, original_tests) -> dict[overlap_pct, matching_tests, missing_tests]
      - determine_reconciliation_mode(overlap_result, supersession_reason) -> str (propagate|retest|supersede)
    thresholds:
      propagate: "overlap_pct >= 90%"
      retest: "overlap_pct < 90%"
      supersede: "User explicitly requests supersession"

  metadata_schema:
    file: "resources/commands/sprint/queue_helpers/test_reconciliation.py"
    remediation_metadata: |
      test_reconciliation:
        failed_test_id: "test-8.t-001"
        test_file: "tests/test_auth.py"
        failure_summary: "Auth timeout"
        original_story_id: "8"  # <-- Used to find blocked validation
        reconciliation_status: "pending|fixed|superseded|deferred"

# Implementation Design

## STEP 14: Trigger Reconciliation (Conditional)

### Detection Logic
```markdown
Agent: After STEP 13 completion announcement, check if this is a remediation story.

**Remediation Story Detection**:
```bash
# Get parent story ID
PARENT_ID="${NEXT_STORY.parent}"

# Check if parent ID indicates remediation story
# Patterns: starts with 'R' or contains '.r.'
echo "${PARENT_ID}" | grep -qE '^R[0-9]|\.r\.'
IS_REMEDIATION=$?
```

**IF IS_REMEDIATION == 0** (is remediation):
  Continue to reconciliation trigger
**ELSE** (not remediation):
  Skip STEP 14, end testing phase
```

### Validation Discovery
```markdown
**IF IS_REMEDIATION**:

Agent: Find the blocked validation story that this remediation addresses.

```bash
# Get remediation metadata from parent story
REMEDIATION_METADATA=$(python "${SCRIPT_DIR}/queue_helpers.py" get-story \
  --story-id "${PARENT_ID}" --json | jq -r '.metadata.test_reconciliation')

# Extract original story ID
ORIGINAL_STORY_ID=$(echo "${REMEDIATION_METADATA}" | jq -r '.original_story_id')

# Construct validation testing story ID
VALIDATION_ID="-${ORIGINAL_STORY_ID}.t"
```

Agent: Store as VALIDATION_ID.

**Verify validation exists and is blocked**:

```bash
python "${SCRIPT_DIR}/queue_helpers.py" get-story \
  --story-id "${VALIDATION_ID}" --json
```

Agent: Store as VALIDATION_STORY.

**IF VALIDATION_STORY not found OR status != "blocked"**:
```
Announce: "ℹ️ No blocked validation found for reconciliation - skipping"
END STEP 14
```

**IF VALIDATION_STORY.status == "blocked"**:
```
Continue to overlap calculation
```
```

### Overlap Calculation
```markdown
Agent: Calculate test overlap between remediation and original validation.

```bash
# Load test results from this remediation.t story
REMEDIATION_RESULTS_FILE=".claude/sprint/test-results/${PARENT_ID}-results.json"
REMEDIATION_RESULTS=$(cat "${REMEDIATION_RESULTS_FILE}")

# Load test results from blocked validation
VALIDATION_RESULTS_FILE=".claude/sprint/test-results/${ORIGINAL_STORY_ID}-results.json"

# Check if validation has test results
if [[ -f "${VALIDATION_RESULTS_FILE}" ]]; then
  VALIDATION_RESULTS=$(cat "${VALIDATION_RESULTS_FILE}")
else
  # If no test results, assume empty test set
  VALIDATION_RESULTS='{"summary": {"total_tests": 0}, "test_files": []}'
fi
```

Agent: Parse both result files to extract test file lists.

```bash
# Calculate overlap using queue_helpers
python "${SCRIPT_DIR}/queue_helpers.py" calculate-overlap \
  --remediation-tests "${REMEDIATION_RESULTS}" \
  --original-tests "${VALIDATION_RESULTS}" \
  --json
```

Agent: Store as OVERLAP_RESULT.

**Expected format**:
```json
{
  "overlap_pct": 85.0,
  "matching_tests": 17,
  "total_original_tests": 20,
  "missing_tests": ["test_auth.py::test_timeout", "test_auth.py::test_refresh"],
  "extra_tests": ["test_auth.py::test_new_flow"]
}
```
```

### Mode Determination
```markdown
Agent: Determine reconciliation mode based on overlap.

```bash
# Determine mode
python "${SCRIPT_DIR}/queue_helpers.py" determine-mode \
  --overlap-pct "${OVERLAP_RESULT.overlap_pct}" \
  --json
```

Agent: Store as RECONCILIATION_MODE (one of: "propagate", "retest", "supersede").

**Mode Selection Logic**:
- **propagate**: overlap_pct >= 90%
- **retest**: overlap_pct < 90%
- **supersede**: User explicitly requested (not auto-detected)

For Story 6, we only implement **propagate** and **retest** modes.
Supersession requires user intervention (out of scope for automatic trigger).
```

### Apply Reconciliation
```markdown
Agent: Apply the determined reconciliation mode.

**IF RECONCILIATION_MODE == "propagate"**:

```bash
python "${SCRIPT_DIR}/queue_helpers.py" apply-reconciliation \
  --mode propagate \
  --target "${VALIDATION_ID}" \
  --source "${NEXT_STORY.story_id}" \
  --test-results "${REMEDIATION_RESULTS}" \
  --json
```

**IF RECONCILIATION_MODE == "retest"**:

```bash
# Construct retest reason with overlap details
RETEST_REASON="Test overlap ${OVERLAP_RESULT.overlap_pct}% (${OVERLAP_RESULT.matching_tests}/${OVERLAP_RESULT.total_original_tests} tests) - retest required"

python "${SCRIPT_DIR}/queue_helpers.py" apply-reconciliation \
  --mode retest \
  --target "${VALIDATION_ID}" \
  --source "${NEXT_STORY.story_id}" \
  --test-results "${REMEDIATION_RESULTS}" \
  --reason "${RETEST_REASON}" \
  --json
```

Agent: Store as RECONCILIATION_RESULT.

**Expected result format**:
```json
{
  "status": "success|error|skipped",
  "mode": "propagate|retest",
  "target": "-8.t",
  "source": "R1.t",
  "message": "Propagated results from R1.t to -8.t (100.0% pass rate)",
  "updated_stories": ["-8.t", "-8"]
}
```
```

### User Announcement
```markdown
Agent: Announce reconciliation outcome to user.

**IF RECONCILIATION_RESULT.status == "success"**:

**AND RECONCILIATION_MODE == "propagate"**:

Announce:
```
✅ Reconciliation: Propagated Results

Remediation: ${NEXT_STORY.story_id} (${PARENT_ID})
Validation: ${VALIDATION_ID} → COMPLETED
Overlap: ${OVERLAP_RESULT.overlap_pct}% (${OVERLAP_RESULT.matching_tests}/${OVERLAP_RESULT.total_original_tests} tests)

Result: Validation ${VALIDATION_ID} marked as completed
        Pass results propagated from ${NEXT_STORY.story_id}
        ${RECONCILIATION_RESULT.message}

Updated stories:
${RECONCILIATION_RESULT.updated_stories.join('\n')}

Next: Run /sprint:NEXT to continue sprint execution
```

**AND RECONCILIATION_MODE == "retest"**:

Announce:
```
⚠️ Reconciliation: Retest Required

Remediation: ${NEXT_STORY.story_id} (${PARENT_ID})
Validation: ${VALIDATION_ID} → UNBLOCKED (needs retest)
Overlap: ${OVERLAP_RESULT.overlap_pct}% (${OVERLAP_RESULT.matching_tests}/${OVERLAP_RESULT.total_original_tests} tests)

Missing tests: ${OVERLAP_RESULT.missing_tests.join(', ')}

Result: Validation ${VALIDATION_ID} unblocked and ready for execution
        Retest required due to insufficient overlap (< 90%)
        ${RECONCILIATION_RESULT.message}

Next: Run /sprint:NEXT --story ${VALIDATION_ID} to execute validation tests
```

**IF RECONCILIATION_RESULT.status == "error"**:

Announce:
```
❌ Reconciliation Failed

Error: ${RECONCILIATION_RESULT.error}
Target: ${VALIDATION_ID}
Source: ${NEXT_STORY.story_id}

Manual intervention required.
Check queue state: /sprint:QUEUE
```

**IF RECONCILIATION_RESULT.status == "skipped"**:

Announce:
```
ℹ️ Reconciliation Skipped

Reason: ${RECONCILIATION_RESULT.reason}
Validation: ${VALIDATION_ID}
Remediation: ${NEXT_STORY.story_id}

No action taken.
```
```

# queue_helpers.py CLI Commands (Story 7 Dependency)

The following CLI commands will be implemented in Story 7 to support the above flow:

```bash
# Calculate test overlap
python queue_helpers.py calculate-overlap \
  --remediation-tests JSON \
  --original-tests JSON \
  --json

# Determine reconciliation mode
python queue_helpers.py determine-mode \
  --overlap-pct FLOAT \
  --json

# Apply reconciliation
python queue_helpers.py apply-reconciliation \
  --mode {propagate|retest|supersede} \
  --target VALIDATION_ID \
  --source REMEDIATION_ID \
  --test-results JSON \
  [--reason REASON] \
  --json
```

For Story 6 implementation, we will invoke the Python functions directly from the helper module until Story 7 provides the CLI interface.

# Direct Function Invocation Pattern (Temporary)

Since Story 7 (CLI commands) is a dependency, we'll invoke functions directly:

```bash
# Instead of CLI commands, use Python module invocation
python -c "
from resources.commands.sprint.queue_helpers.overlap import calculate_test_overlap
import json
import sys

remediation = json.loads('${REMEDIATION_RESULTS}')
original = json.loads('${VALIDATION_RESULTS}')

result = calculate_test_overlap(
    remediation_tests=remediation.get('test_files', []),
    original_tests=original.get('test_files', [])
)

print(json.dumps(result))
"
```

This pattern avoids dependency on Story 7 completion.

# Error Handling

error_cases:
  - case: "Remediation metadata missing original_story_id"
    handling: "Skip reconciliation, announce warning to user"

  - case: "Blocked validation not found"
    handling: "Skip reconciliation gracefully (validation may have been manually resolved)"

  - case: "Test results file missing for remediation"
    handling: "Error - cannot calculate overlap without test results"

  - case: "Test results file missing for original validation"
    handling: "Assume empty test set (new tests added by remediation)"

  - case: "Overlap calculation fails"
    handling: "Report error to user, do not apply reconciliation"

  - case: "Reconciliation application fails (queue update error)"
    handling: "Report error, manual intervention required"

  - case: "Multiple blocked validations match pattern"
    handling: "Use first match, log warning about ambiguity"

# Test Requirements
test_requirements:
  unit:
    - "Test remediation story detection (parent ID patterns)"
    - "Test validation discovery from remediation metadata"
    - "Test reconciliation trigger when validation blocked"
    - "Test reconciliation skip when validation not blocked"
    - "Test reconciliation skip when validation not found"
    - "Test propagate mode announcement (overlap >= 90%)"
    - "Test retest mode announcement (overlap < 90%)"
    - "Test error handling for missing metadata"
    - "Test error handling for missing test results"
    - "Test user message formatting for all modes"

  integration:
    - "Test full flow: remediation.t passes -> overlap calculated -> propagate applied -> user notified"
    - "Test full flow: remediation.t passes -> overlap insufficient -> retest applied -> user notified"
    - "Test reconciliation with real queue (.queue.json updated correctly)"
    - "Test reconciliation with real test results files"
    - "Test remediation without blocked validation (graceful skip)"
    - "Test non-remediation story skips reconciliation trigger"
    - "Test container status propagation after reconciliation"

  security:
    - "Test malicious story IDs in remediation metadata"
    - "Test path traversal attempts in test results files"
    - "Test script injection in user announcement messages"

# Acceptance Criteria Mapping
acceptance_criteria:
  - id: "AC-6.1"
    text: "(P0) on_remediation_testing_complete() called after successful remediation.t"
    implementation: "STEP 14 in execute-testing.md, conditional on remediation detection"
    tests: "test_requirements.integration[0-1]"

  - id: "AC-6.2"
    text: "(P0) Reconciliation result reported to user with clear status message"
    implementation: "User announcement section with mode-specific messaging"
    tests: "test_requirements.unit[9], test_requirements.integration[0-1]"

  - id: "AC-6.3"
    text: "Mode selection based on overlap calculation"
    implementation: "determine_reconciliation_mode() called with overlap result"
    tests: "test_requirements.integration[0-1]"

  - id: "AC-6.4"
    text: "Failed remediation tests do not trigger reconciliation"
    implementation: "STEP 14 only executes after successful test completion (pass_rate >= 90%)"
    tests: "test_requirements.integration[5]"

  - id: "AC-6.5"
    text: "Integration test for end-to-end flow"
    implementation: "Full remediation.t -> reconciliation -> user notification flow"
    tests: "test_requirements.integration[0-1]"

# Dependencies
dependencies:
  - story_id: "4"
    type: "requires"
    reason: "Uses reconciliation application functions (apply_propagate_reconciliation, etc.)"

  - story_id: "3"
    type: "requires"
    reason: "Uses overlap calculation (calculate_test_overlap, determine_reconciliation_mode)"

  - story_id: "1"
    type: "requires"
    reason: "Uses test_reconciliation metadata schema"

  - story_id: "2"
    type: "requires"
    reason: "Remediation stories must have test_reconciliation metadata"

# Blocks
blocks:
  - story_id: "7"
    reason: "CLI commands for reconciliation will use the same workflow pattern"

# Implementation Notes
implementation_notes:
  - note: "STEP 14 is conditional - only runs for remediation.t stories"
    rationale: "Regular feature stories don't need reconciliation"

  - note: "Reconciliation only triggers on successful test completion (pass_rate >= 90%)"
    rationale: "Failed remediation tests should not update blocked validation state"

  - note: "Use direct Python function invocation instead of CLI commands (Story 7 not complete)"
    rationale: "Avoid dependency on Story 7 completion"

  - note: "Gracefully skip reconciliation if blocked validation not found"
    rationale: "Validation may have been manually resolved or deleted"

  - note: "User messages must be clear and actionable (explain what happened, what to do next)"
    rationale: "User needs to understand reconciliation outcome and next steps"

  - note: "Supersession mode not implemented in automatic trigger (requires user decision)"
    rationale: "Supersession is a deliberate choice, not an automatic decision"

  - note: "Test results file paths follow pattern: .claude/sprint/test-results/{story_id}-results.json"
    rationale: "Consistent with existing testing phase artifact generation"

# Future Enhancements (Out of Scope for Story 6)
future_enhancements:
  - "Manual reconciliation trigger via CLI (Story 7 will enable this)"
  - "Supersession mode support (requires user confirmation)"
  - "Partial reconciliation (some tests propagated, others retested)"
  - "Configurable overlap thresholds per-project"
  - "Reconciliation analytics and reporting"
  - "Batch reconciliation for multiple blocked validations"
