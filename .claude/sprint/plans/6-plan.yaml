# Plan: Story 6 - Session Manager Updates
# Generated by: discovery:6.d
# Timestamp: 2025-12-09T09:00:00Z

story_id: "6"
title: "Session Manager Updates"
created: "2025-12-09T09:00:00Z"
created_by: "discovery:6.d"

# Analysis Summary
analysis:
  summary: "Update SessionManager to extract project namespace metadata from session paths and pass it to storage with global group_id. Requires changes to session_manager.py and graphiti_mcp_server.py callback."
  complexity: "medium"
  estimated_files: 3
  estimated_tokens: 6000
  risk_factors:
    - "Callback signature change affects MCP server integration"
    - "Need to propagate namespace metadata through ResilientSessionIndexer"
    - "Backward compatibility with existing callers"

# Dependencies Analysis
dependencies:
  upstream:
    - story_id: "3"
      title: "Path Resolver Enhancements"
      status: "completed"
      provides:
        - "ClaudePathResolver.get_global_group_id(hostname: str) -> str"
        - "ClaudePathResolver.get_project_path_from_hash(project_hash: str) -> Optional[str]"
    - story_id: "5"
      title: "Graphiti Storage Integration"
      status: "completed"
      provides:
        - "SessionStorage.store_session() with project_namespace, project_path, hostname, include_project_path params"
  downstream:
    - story_id: "7"
      title: "MCP Server Search Filter Implementation"
      uses: "Global group_id for search queries"

# Files to Create
files_to_create: []  # No new files needed

# Files to Modify
files_to_modify:
  - path: "graphiti_core/session_tracking/session_manager.py"
    changes:
      - "Add import: socket module"
      - "Add optional config parameter to __init__ for session tracking settings"
      - "Store config reference: self.config = config"
      - "Modify _close_session to extract and log namespace metadata"
      - "Extract project_namespace using path_resolver.resolve_project_from_session_file()"
      - "Get project_path using path_resolver.get_project_path_from_hash()"
      - "Compute global group_id using config.group_id or path_resolver.get_global_group_id()"
      - "Add DEBUG logging for namespace information"
      - "Pass namespace metadata through callback (extend context or add return values)"
    lines_affected: 60

  - path: "graphiti_core/session_tracking/resilient_indexer.py"
    changes:
      - "Add new parameters to index_session(): project_namespace, project_path, hostname, include_project_path"
      - "Pass parameters to underlying _indexer.index_session()"
      - "Update metadata dict to include namespace fields"
    lines_affected: 30

  - path: "graphiti_core/session_tracking/indexer.py"
    changes:
      - "Add new parameters to index_session(): project_namespace, project_path, hostname, include_project_path"
      - "Import build_episode_metadata_header from .metadata"
      - "Build and prepend metadata header when project_namespace is provided"
      - "Update source_description to include namespace prefix"
    lines_affected: 40

  - path: "mcp_server/graphiti_mcp_server.py"
    changes:
      - "Import socket module"
      - "Update on_session_closed callback to extract namespace metadata"
      - "Compute global group_id using config.group_id or path_resolver.get_global_group_id()"
      - "Pass namespace metadata to resilient_indexer.index_session()"
      - "Update SessionManager instantiation to pass config reference"
    lines_affected: 25

# Integration Points
integration:
  - file: "graphiti_core/session_tracking/session_manager.py"
    type: "method_modification"
    description: "Modify __init__ and _close_session to handle namespace metadata"

  - file: "graphiti_core/session_tracking/indexer.py"
    type: "method_modification"
    description: "Extend index_session() to build metadata header (similar to graphiti_storage.py)"

  - file: "mcp_server/graphiti_mcp_server.py"
    type: "callback_modification"
    description: "Update on_session_closed to extract and pass namespace metadata"

# Patterns to Follow
patterns:
  - source: "graphiti_core/session_tracking/graphiti_storage.py:49-140"
    pattern: "Follow the same metadata header building pattern used in store_session()"
  - source: "graphiti_core/session_tracking/path_resolver.py:285-298"
    pattern: "Use get_global_group_id() for hostname-based global ID"
  - source: "mcp_server/graphiti_mcp_server.py:2566-2597"
    pattern: "Follow existing callback structure for on_session_closed"

# Implementation Details
implementation:
  session_manager_init:
    current_signature: |
      def __init__(
          self,
          path_resolver: ClaudePathResolver,
          inactivity_timeout: int = 300,
          keep_length_days: Optional[int] = 7,
          on_session_closed: Optional[Callable[[str, Path, ConversationContext], None]] = None,
      )
    new_signature: |
      def __init__(
          self,
          path_resolver: ClaudePathResolver,
          inactivity_timeout: int = 300,
          keep_length_days: Optional[int] = 7,
          on_session_closed: Optional[Callable[[str, Path, ConversationContext], None]] = None,
          config: Optional["SessionTrackingConfig"] = None,  # NEW: for namespace settings
      )
    notes:
      - "config is optional for backward compatibility"
      - "Store as self.config = config"

  close_session_namespace_extraction:
    description: "Extract namespace metadata in _close_session method"
    logic: |
      # At start of _close_session, after session validation:
      import socket

      # Extract project namespace from session file path
      project_namespace = self.path_resolver.resolve_project_from_session_file(
          session.file_path
      )

      # Get human-readable project path (if config allows)
      project_path = None
      include_project_path = True
      if self.config:
          include_project_path = self.config.include_project_path
          if include_project_path and project_namespace:
              project_path = self.path_resolver.get_project_path_from_hash(
                  project_namespace
              )

      # Compute global group_id
      hostname = socket.gethostname()
      if self.config and self.config.group_id:
          group_id = self.config.group_id
      else:
          group_id = self.path_resolver.get_global_group_id(hostname)

      # Log namespace information (DEBUG level)
      logger.debug(
          f"Indexing session from namespace {project_namespace[:8] if project_namespace else 'unknown'} "
          f"to group {group_id}"
      )

  indexer_metadata_header:
    description: "Build metadata header in indexer.py when namespace provided"
    logic: |
      from .metadata import build_episode_metadata_header

      # In index_session(), after building episode name:
      if project_namespace is not None:
          effective_hostname = hostname or socket.gethostname()

          metadata_header = build_episode_metadata_header(
              project_namespace=project_namespace,
              project_path=project_path,
              hostname=effective_hostname,
              session_file=session_file or f"session-{session_id[:8]}.jsonl",
              message_count=0,  # Will be updated when available
              duration_minutes=0,  # Will be updated when available
              include_project_path=include_project_path,
          )
          episode_body = metadata_header + filtered_content

          # Update source description with namespace prefix
          source_description = (
              f"[{project_namespace[:8]}] "
              f"Filtered Claude Code session {session_id}"
          )
      else:
          episode_body = filtered_content
          source_description = f"Filtered Claude Code session {session_id}"

  mcp_server_callback:
    description: "Update on_session_closed to pass namespace metadata"
    logic: |
      def on_session_closed(session_id: str, file_path: Path, context) -> None:
          """Callback when session closes - filter and index to Graphiti with resilience."""
          try:
              logger.info(f"Session closed: {session_id}, indexing to Graphiti...")

              # Filter conversation
              filtered_messages = session_filter.filter_conversation(context.messages)
              filtered_content = "\n\n".join([
                  f"[{msg.role}]: {msg.content}" for msg in filtered_messages
              ])

              # Extract namespace metadata (NEW)
              import socket
              project_namespace = path_resolver.resolve_project_from_session_file(file_path)

              # Get human-readable project path (if config allows)
              project_path = None
              if unified_config.session_tracking.include_project_path and project_namespace:
                  project_path = path_resolver.get_project_path_from_hash(project_namespace)

              # Compute global group_id (NEW - was project-specific before)
              hostname = socket.gethostname()
              if unified_config.session_tracking.group_id:
                  group_id = unified_config.session_tracking.group_id
              else:
                  group_id = path_resolver.get_global_group_id(hostname)

              logger.debug(
                  f"Indexing session from namespace {project_namespace[:8] if project_namespace else 'unknown'} "
                  f"to group {group_id}"
              )

              # Index to Graphiti with namespace metadata (UPDATED)
              loop = asyncio.get_event_loop()
              loop.create_task(resilient_indexer.index_session(
                  session_id=session_id,
                  filtered_content=filtered_content,
                  group_id=group_id,
                  session_file=str(file_path),
                  # NEW parameters:
                  project_namespace=project_namespace,
                  project_path=project_path,
                  hostname=hostname,
                  include_project_path=unified_config.session_tracking.include_project_path,
              ))

              logger.info(f"Session {session_id} indexing initiated ({len(filtered_messages)} messages)")

          except Exception as e:
              logger.error(f"Error indexing session {session_id}: {e}", exc_info=True)

# Test Requirements
test_requirements:
  unit:
    - "test_session_manager_extracts_namespace: Verify project_namespace extracted from session path"
    - "test_session_manager_gets_project_path: Verify project_path lookup works"
    - "test_session_manager_computes_global_group_id: Verify global group_id format"
    - "test_session_manager_uses_config_group_id: Verify configured group_id takes precedence"
    - "test_session_manager_respects_include_project_path: Verify path is omitted when config says so"
    - "test_session_manager_logs_namespace_debug: Verify DEBUG logging of namespace info"
    - "test_indexer_with_namespace_metadata: Verify metadata header is prepended"
    - "test_indexer_without_namespace: Verify backward compatibility (no namespace = no header)"
    - "test_indexer_source_description_prefix: Verify namespace prefix in source_description"
  integration:
    - "test_session_close_indexes_with_global_group_id: End-to-end from session close to Graphiti"
    - "test_cross_project_sessions_use_same_group_id: Multiple projects index to same group"
  security: []

# Acceptance Criteria Mapping
acceptance_criteria:
  - id: "AC-6.1"
    priority: "P0"
    text: "Session manager extracts project_namespace from session path"
    implementation: "session_manager.py:_close_session - call path_resolver.resolve_project_from_session_file()"
    tests: "test_session_manager_extracts_namespace"

  - id: "AC-6.2"
    priority: "P0"
    text: "Session manager extracts project_path (if config allows)"
    implementation: "session_manager.py:_close_session - call path_resolver.get_project_path_from_hash()"
    tests: "test_session_manager_gets_project_path, test_session_manager_respects_include_project_path"

  - id: "AC-6.3"
    priority: "P0"
    text: "Passes namespace metadata to store_session()"
    implementation: "mcp_server/graphiti_mcp_server.py - update callback to pass namespace params"
    tests: "test_session_close_indexes_with_global_group_id"

  - id: "AC-6.4"
    priority: "P0"
    text: "Uses global group_id from config (not project-specific)"
    implementation: "session_manager.py + mcp_server - compute using get_global_group_id() or config.group_id"
    tests: "test_session_manager_computes_global_group_id, test_session_manager_uses_config_group_id"

  - id: "AC-6.5"
    priority: "P1"
    text: "Logs namespace information at DEBUG level"
    implementation: "session_manager.py:_close_session - logger.debug() call"
    tests: "test_session_manager_logs_namespace_debug"

# Notes for Implementation Phase
notes:
  - "The primary change point is the MCP server callback - that's where the indexing flow is orchestrated"
  - "SessionManager doesn't directly call storage - it invokes the callback with context"
  - "The callback (in mcp_server) needs to extract namespace and pass to resilient_indexer"
  - "resilient_indexer.index_session() needs to be extended to accept namespace params"
  - "indexer.py needs to build metadata header (like graphiti_storage.py does)"
  - "All new params should have defaults for backward compatibility"
  - "Story 5 already implemented metadata in graphiti_storage.py - follow same pattern for indexer.py"
