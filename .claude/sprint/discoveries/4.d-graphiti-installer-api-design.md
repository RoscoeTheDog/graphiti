# Discovery: GraphitiInstaller Class API Design

**Story**: 4.d - Create GraphitiInstaller Class (Discovery Phase)
**Created**: 2025-12-25
**Status**: Complete

---

## Overview

This document defines the API design, error handling strategy, and progress reporting mechanism for the `GraphitiInstaller` class that will orchestrate installation, upgrade, and uninstall workflows for the Graphiti MCP server.

---

## 1. Installer API Design

### Class: `GraphitiInstaller`

**Location**: `mcp_server/daemon/installer.py`

**Purpose**: Orchestrate complete installation, upgrade, and uninstall workflows for the Graphiti MCP server following professional daemon architecture (v2.1).

### Constructor

```python
def __init__(self, progress_callback: Optional[ProgressCallback] = None):
    """
    Initialize GraphitiInstaller.

    Args:
        progress_callback: Optional callback for progress reporting
                          Signature: (step: str, progress: int, total: int, message: str) -> None

    Attributes:
        paths: GraphitiPaths instance (from paths.py)
        service_manager: Platform-specific service manager
        progress: ProgressReporter instance
    """
```

### Primary Methods

#### 1. `install()`

```python
def install(self, source_dir: Optional[Path] = None) -> InstallationResult:
    """
    Install Graphiti MCP server to platform-appropriate location.

    Args:
        source_dir: Path to source repository (default: auto-detect via Path(__file__))

    Returns:
        InstallationResult with success status, version, and install paths

    Raises:
        InstallationError: On validation, disk, or permission errors

    Steps:
        1. _validate_environment() - Check Python version, disk space, permissions
        2. _create_directories() - Create install_dir, config_dir, state_dir
        3. _create_venv() - Create virtual environment in install_dir/bin
        4. _install_dependencies() - Install pip packages from requirements.txt
        5. _freeze_packages() - Copy mcp_server and graphiti_core to lib/
        6. _create_wrappers() - Generate platform executables (graphiti-mcp.exe, etc.)
        7. _write_version_info() - Write VERSION and INSTALL_INFO files
        8. _create_default_config() - Generate graphiti.config.json in config_dir
        9. _register_service() - Register with Task Scheduler/launchd/systemd
        10. _start_service() - Start bootstrap service
        11. _verify_installation() - Health check via MCP connection

    Rollback:
        On failure at any step, calls _cleanup_on_failure() to remove partial install
    """
```

#### 2. `upgrade()`

```python
def upgrade(self, source_dir: Optional[Path] = None, force: bool = False) -> InstallationResult:
    """
    Upgrade existing Graphiti installation to new version.

    Args:
        source_dir: Path to new version source (default: auto-detect)
        force: Skip version check and force upgrade

    Returns:
        InstallationResult with new version info

    Raises:
        InstallationError: If no existing install, version conflict, or upgrade fails
        UpgradeError: If rollback fails (critical - manual intervention required)

    Steps:
        1. _detect_existing_version() - Read VERSION file, validate install
        2. _stop_service() - Gracefully stop bootstrap service
        3. _backup_installation() - Create timestamped backup of lib/ directory
        4. _freeze_packages() - Copy new packages to lib/
        5. _update_version_info() - Update VERSION and INSTALL_INFO
        6. _migrate_config() - Migrate config if schema changed (via ConfigMigration)
        7. _start_service() - Start service with new code
        8. _verify_health() - Health check with 30s timeout
        9. _remove_backup() - Clean up backup on success

    Rollback:
        On failure, calls _rollback_upgrade() to restore from backup
    """
```

#### 3. `uninstall()`

```python
def uninstall(self, keep_config: bool = True, keep_logs: bool = False) -> bool:
    """
    Uninstall Graphiti MCP server.

    Args:
        keep_config: Preserve config_dir (default: True - don't lose user settings)
        keep_logs: Preserve state_dir/logs (default: False - clean removal)

    Returns:
        True on successful uninstall

    Raises:
        InstallationError: If service stop fails or removal blocked by OS

    Steps:
        1. _stop_service() - Gracefully stop bootstrap
        2. _unregister_service() - Remove from Task Scheduler/launchd/systemd
        3. _remove_install_dir() - Delete install_dir (executables and libs)
        4. _remove_state_dir() - Delete state_dir if not keep_logs
        5. _remove_config_dir() - Delete config_dir if not keep_config
        6. _verify_removal() - Check all directories removed as requested
    """
```

### Helper Methods (Internal)

#### Validation

```python
def _validate_environment(self) -> None:
    """
    Validate system meets installation requirements.

    Checks:
        - Python version >= 3.9
        - Disk space >= 500MB in install location
        - Write permissions to install_dir parent
        - No existing installation (or call upgrade() instead)

    Raises:
        ValidationError: With specific requirement that failed
    """
```

#### Directory Management

```python
def _create_directories(self) -> None:
    """
    Create all required directories for installation.

    Creates:
        - install_dir/bin/
        - install_dir/lib/
        - config_dir/
        - state_dir/logs/
        - state_dir/data/
        - state_dir/data/sessions/

    Raises:
        PermissionError: If directory creation blocked by OS
    """
```

#### Cleanup

```python
def _cleanup_on_failure(self) -> None:
    """
    Remove partial installation after failure.

    Steps:
        - Log failure state to install.log
        - Stop any running service
        - Remove install_dir if created
        - Remove config_dir if created (only if empty - preserve user edits)
        - Remove state_dir if created

    Note:
        Uses safe removal with logging - does not raise exceptions
    """

def _rollback_upgrade(self, backup_path: Path) -> None:
    """
    Restore installation from backup after failed upgrade.

    Args:
        backup_path: Path to backup directory (e.g., lib.backup-20251225-143022)

    Steps:
        - Stop service
        - Remove new lib/
        - Restore lib/ from backup
        - Start service
        - Verify health

    Raises:
        UpgradeError: If rollback fails (critical - requires manual fix)
    """
```

---

## 2. Error Handling Strategy

### Exception Hierarchy

```python
class InstallationError(Exception):
    """Base exception for all installation errors."""

    def __init__(self, message: str, step: str = None, details: Dict[str, Any] = None):
        """
        Args:
            message: Human-readable error message
            step: Installation step that failed (e.g., "validate_environment")
            details: Additional context (e.g., {"disk_space_mb": 120, "required_mb": 500})
        """
        self.message = message
        self.step = step
        self.details = details or {}
        super().__init__(message)

class ValidationError(InstallationError):
    """System does not meet installation requirements."""
    pass

class PermissionError(InstallationError):
    """Insufficient permissions for installation."""
    pass

class ServiceError(InstallationError):
    """Service registration or management failed."""
    pass

class UpgradeError(InstallationError):
    """Upgrade failed and rollback unsuccessful (critical)."""
    pass
```

### Error Handling Pattern

**Install Method Example**:

```python
def install(self, source_dir: Optional[Path] = None) -> InstallationResult:
    try:
        self.progress.start("Installing Graphiti MCP Server", total_steps=11)

        self.progress.step(1, "Validating environment")
        self._validate_environment()

        self.progress.step(2, "Creating directories")
        self._create_directories()

        # ... remaining steps

        self.progress.complete("Installation successful")
        return InstallationResult(success=True, version=version, paths=self.paths)

    except ValidationError as e:
        # User action required (e.g., upgrade Python, free disk space)
        self.progress.error(f"Validation failed: {e.message}")
        raise

    except PermissionError as e:
        # Permission issue - suggest running with appropriate privileges
        self.progress.error(f"Permission denied: {e.message}")
        raise

    except Exception as e:
        # Unexpected error - cleanup and re-raise
        self.progress.error(f"Installation failed: {str(e)}")
        self._cleanup_on_failure()
        raise InstallationError(f"Unexpected error: {str(e)}", step="unknown") from e
```

### Logging Strategy

**Dual Logging**:
1. **Console**: Human-readable progress via ProgressReporter
2. **File**: Detailed technical log at `state_dir/logs/install.log`

**Log Levels**:
- `INFO`: Normal progress (each step completion)
- `WARNING`: Recoverable issues (e.g., backup directory exists, using alternate)
- `ERROR`: Failures that trigger cleanup/rollback
- `CRITICAL`: Unrecoverable errors (e.g., rollback failed)

**Log Format**:
```
2025-12-25 14:30:45 [INFO] Starting installation (version 2.1.0)
2025-12-25 14:30:45 [INFO] Step 1/11: Validating environment
2025-12-25 14:30:46 [INFO] Python 3.12.1 detected (requirement: >= 3.9)
2025-12-25 14:30:46 [INFO] Disk space: 15.2 GB available (requirement: >= 500 MB)
2025-12-25 14:30:46 [ERROR] Installation failed at step 'create_directories': Permission denied
2025-12-25 14:30:46 [INFO] Starting cleanup...
```

---

## 3. Progress Reporting Mechanism

### ProgressReporter Class

```python
class ProgressReporter:
    """Handle progress reporting via callback and logging."""

    def __init__(self, callback: Optional[ProgressCallback] = None):
        """
        Args:
            callback: Optional function to report progress
                     Signature: (step: str, progress: int, total: int, message: str) -> None
        """
        self.callback = callback
        self.current_step = 0
        self.total_steps = 0
        self.operation = ""

    def start(self, operation: str, total_steps: int) -> None:
        """Begin progress tracking for an operation."""
        self.operation = operation
        self.total_steps = total_steps
        self.current_step = 0
        self._report(f"Starting: {operation}")

    def step(self, step_num: int, message: str) -> None:
        """Report progress for a specific step."""
        self.current_step = step_num
        self._report(message)

    def complete(self, message: str) -> None:
        """Report successful completion."""
        self.current_step = self.total_steps
        self._report(f"✓ {message}")

    def error(self, message: str) -> None:
        """Report error."""
        self._report(f"✗ {message}")

    def _report(self, message: str) -> None:
        """Internal: Send to callback and log."""
        # Console output
        if self.callback:
            self.callback(
                step=self.operation,
                progress=self.current_step,
                total=self.total_steps,
                message=message
            )
        else:
            # Default: print to console
            if self.total_steps > 0:
                pct = int((self.current_step / self.total_steps) * 100)
                print(f"[{pct:3d}%] {message}")
            else:
                print(message)

        # File logging
        logger.info(f"Step {self.current_step}/{self.total_steps}: {message}")
```

### Progress Callback Type

```python
from typing import Callable

ProgressCallback = Callable[[str, int, int, str], None]
# Args: (step_name, current_step, total_steps, message)
```

### Usage Example

**CLI Integration**:

```python
# Simple console output (default)
installer = GraphitiInstaller()
installer.install()

# Custom progress handler (e.g., for GUI)
def show_progress(step: str, progress: int, total: int, message: str):
    update_progress_bar(progress / total)
    set_status_text(message)

installer = GraphitiInstaller(progress_callback=show_progress)
installer.install()
```

**Output Example** (Console):

```
[  0%] Starting: Installing Graphiti MCP Server
[  9%] Step 1/11: Validating environment
[  9%] Python 3.12.1 detected (requirement: >= 3.9)
[  9%] Disk space: 15.2 GB available (requirement: >= 500 MB)
[ 18%] Step 2/11: Creating directories
[ 18%] Created: C:\Users\Admin\AppData\Local\Programs\Graphiti
[ 27%] Step 3/11: Creating virtual environment
...
[100%] ✓ Installation successful
```

---

## 4. Code Reuse from DaemonManager

### Reusable Components

Based on analysis of `mcp_server/daemon/manager.py`, the following can be reused:

#### 1. Service Manager Selection

**From**: `DaemonManager._get_service_manager()`

```python
# Current implementation (manager.py:52-64)
def _get_service_manager(self):
    if self.platform == 'windows':
        from .service_managers.windows import WindowsTaskSchedulerManager
        return WindowsTaskSchedulerManager()
    elif self.platform == 'darwin':
        from .service_managers.macos import LaunchdServiceManager
        return LaunchdServiceManager()
    elif self.platform == 'linux':
        from .service_managers.linux import SystemdServiceManager
        return SystemdServiceManager()
```

**Reuse Strategy**: GraphitiInstaller can import this utility directly or use composition:

```python
def __init__(self):
    self.paths = get_paths()
    self.service_manager = self._get_service_manager()  # Reuse logic
```

#### 2. Config Creation

**From**: `DaemonManager._create_default_config()`

**Reuse Strategy**: GraphitiInstaller can delegate to this existing method or extract it to a shared utility:

```python
# Option 1: Composition
daemon_manager = DaemonManager()
daemon_manager._create_default_config()

# Option 2: Extract to shared utility (preferred)
from mcp_server.daemon.config_utils import create_default_config
create_default_config(config_path=self.paths.config_file)
```

#### 3. Components NOT Reused

**DaemonManager.install()**: Current install method (lines 102-251) is v2.0 architecture (home directory install). GraphitiInstaller implements v2.1 (Programs directory + frozen packages), so install logic is new.

**DaemonManager.uninstall()**: Partially reusable - service stop/unregister logic can be shared, but directory removal differs (v2.1 has separate install/config/state dirs).

### Recommended Refactoring

**Before implementing GraphitiInstaller**, extract shared utilities:

1. **Create**: `mcp_server/daemon/service_utils.py`
   - `get_service_manager()` - Factory for platform-specific managers

2. **Create**: `mcp_server/daemon/config_utils.py`
   - `create_default_config(path)` - Generate graphiti.config.json
   - `migrate_config(old_version, new_version)` - Config migration

3. **Keep**: DaemonManager as high-level orchestrator (backward compat for v2.0 users)

4. **New**: GraphitiInstaller as v2.1 orchestrator (frozen packages, versioning)

---

## 5. Installation Result Type

```python
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

@dataclass
class InstallationResult:
    """Result of installation/upgrade/uninstall operation."""

    success: bool
    version: Optional[str] = None
    paths: Optional[GraphitiPaths] = None
    error: Optional[str] = None
    details: Optional[Dict[str, Any]] = None

    def __str__(self) -> str:
        if self.success:
            return f"✓ Installation successful (version {self.version})"
        else:
            return f"✗ Installation failed: {self.error}"
```

---

## 6. Next Steps (Implementation Phase - Story 4.i)

1. **Create file**: `mcp_server/daemon/installer.py`
2. **Implement skeleton**: `GraphitiInstaller` class with all method signatures
3. **Implement**: `_validate_environment()` with Python version and disk space checks
4. **Implement**: `_create_directories()` using `self.paths` from `paths.py`
5. **Implement**: `InstallationError` exception hierarchy
6. **Implement**: `ProgressReporter` class with console output
7. **Stub**: Other methods with `pass` or basic logging

---

## Design Review Checklist

- [x] API signatures defined for install, upgrade, uninstall
- [x] Error handling strategy with exception hierarchy
- [x] Progress reporting mechanism with callback support
- [x] Code reuse opportunities identified from DaemonManager
- [x] Separation of concerns (installer orchestrates, delegates to utils)
- [x] Rollback strategy for failed upgrades
- [x] Logging strategy (console + file)
- [x] Platform-agnostic design (uses paths.py)

---

**Discovery Phase Complete** ✓

This design provides a solid foundation for implementing the GraphitiInstaller class in the implementation phase (Story 4.i).
