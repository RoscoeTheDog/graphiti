# Discovery Plan: Story 3 - Activity Detection from Messages
# Generated: 2025-12-11
# Phase: discovery (3.d)

story:
  id: "3"
  title: "Activity Detection from Messages"
  dependency: "Story 2 (Activity Vector Model)"

# =============================================================================
# DISCOVERY FINDINGS
# =============================================================================

codebase_analysis:
  existing_files:
    - path: "graphiti_core/session_tracking/activity_vector.py"
      purpose: "ActivityVector model (8 dimensions) - Story 2"
      key_interfaces:
        - "ActivityVector.from_signals(signals: dict[str, float]) -> ActivityVector"
        - "ActivityVector.DIMENSIONS: list[str]"
        - "ActivityVector.dominant_activities: list[str]"

    - path: "graphiti_core/session_tracking/types.py"
      purpose: "Type definitions for session tracking"
      key_interfaces:
        - "SessionMessage: dataclass with role, content, tool_calls"
        - "MessageRole: USER/ASSISTANT/SYSTEM enum"
        - "ToolCall: dataclass with tool_name, parameters, status"
        - "ConversationContext: dataclass with messages list"

    - path: "graphiti_core/session_tracking/summarizer.py"
      purpose: "Session summarization (integration target)"
      key_interfaces:
        - "SessionSummary: dataclass with objective, completed_tasks, etc."
        - "SessionSummarizer: orchestrates summarization"

  patterns_found:
    - pattern: "Pydantic models with Field validation"
      location: "activity_vector.py"
      reuse: "Follow same pattern for ActivityDetector"

    - pattern: "Dataclass types with to_dict() methods"
      location: "types.py"
      reuse: "Use existing SessionMessage type as input"

# =============================================================================
# IMPLEMENTATION PLAN
# =============================================================================

implementation:
  file_to_create: "graphiti_core/session_tracking/activity_detector.py"

  classes:
    - name: "ActivityDetector"
      purpose: "Detect activity vector from session messages"
      methods:
        - name: "detect"
          signature: "detect(messages: list[SessionMessage]) -> ActivityVector"
          description: "Main entry point - analyzes messages and returns activity vector"

        - name: "_detect_user_intent_keywords"
          signature: "_detect_user_intent_keywords(messages: list[SessionMessage]) -> dict[str, float]"
          description: "Analyze user messages for intent keywords"
          private: true

        - name: "_detect_error_patterns"
          signature: "_detect_error_patterns(messages: list[SessionMessage]) -> dict[str, float]"
          description: "Detect error indicators in messages"
          private: true

        - name: "_detect_file_patterns"
          signature: "_detect_file_patterns(messages: list[SessionMessage]) -> dict[str, float]"
          description: "Detect file type patterns in messages"
          private: true

        - name: "_combine_signals"
          signature: "_combine_signals(*signal_dicts: dict[str, float]) -> dict[str, float]"
          description: "Combine signals from different sources with capping"
          private: true

  constants:
    - name: "INTENT_KEYWORDS"
      description: "Mapping of activity dimensions to keyword patterns"
      structure: |
        {
          "building": ["implement", "add", "create", "build", "new feature", "develop"],
          "fixing": ["fix", "bug", "error", "broken", "not working", "debug", "resolve"],
          "configuring": ["config", "setup", "install", "environment", "settings", ".env"],
          "exploring": ["how does", "what is", "find", "search", "understand", "explain"],
          "refactoring": ["refactor", "restructure", "reorganize", "clean up", "simplify"],
          "reviewing": ["review", "check", "analyze", "look at", "examine"],
          "testing": ["test", "verify", "validate", "check if", "make sure"],
          "documenting": ["document", "readme", "comment", "docstring", "changelog"]
        }

    - name: "ERROR_PATTERNS"
      description: "Regex patterns indicating error/fix scenarios"
      patterns:
        - "error"
        - "exception"
        - "failed"
        - "traceback"
        - "crash"
        - "TypeError"
        - "ValueError"
        - "KeyError"

    - name: "FILE_PATTERNS"
      description: "File type patterns mapped to activities"
      structure: |
        {
          "configuring": [".env", "config.", ".json", ".yaml", ".toml", "package.json", "pyproject.toml"],
          "testing": ["test_", "_test.", ".spec.", "conftest.py", "pytest.ini"],
          "documenting": ["README", "CHANGELOG", ".md", "docs/", "CONTRIBUTING"]
        }

    - name: "SIGNAL_CAPS"
      description: "Maximum contribution from each signal source"
      values:
        keyword_cap: 0.5
        error_boost: 0.3
        file_boost: 0.25

# =============================================================================
# ALGORITHM DESIGN
# =============================================================================

algorithm:
  step_1_keyword_detection:
    description: "Scan user messages for intent keywords"
    input: "list[SessionMessage] filtered to role=USER"
    output: "dict[str, float] raw keyword counts per dimension"
    logic: |
      1. Filter messages to role=USER only
      2. For each user message content:
         - Lowercase the content
         - For each dimension in INTENT_KEYWORDS:
           - Count matches of keywords in content
           - Increment dimension counter
      3. Normalize counts by total matches
      4. Cap each dimension at SIGNAL_CAPS.keyword_cap

  step_2_error_detection:
    description: "Detect error patterns to boost fixing dimension"
    input: "list[SessionMessage] (all messages)"
    output: "dict[str, float] with potential fixing boost"
    logic: |
      1. Count error pattern matches across ALL messages
      2. If error_count > 3: return {"fixing": SIGNAL_CAPS.error_boost}
      3. If error_count 1-3: return {"fixing": error_count * 0.1}
      4. Else: return empty dict

  step_3_file_detection:
    description: "Detect file type patterns in message content"
    input: "list[SessionMessage] (all messages)"
    output: "dict[str, float] per dimension based on file patterns"
    logic: |
      1. For each dimension in FILE_PATTERNS:
         - Count files matching patterns in all message content
         - If count > 2: add SIGNAL_CAPS.file_boost to dimension
         - If count 1-2: add count * 0.12 to dimension
      2. Return dimension dict

  step_4_combine_signals:
    description: "Combine all signal sources"
    input: "keyword_signals, error_signals, file_signals dicts"
    output: "dict[str, float] combined signals"
    logic: |
      1. Merge all dicts, summing values per dimension
      2. Cap each dimension at 1.0
      3. Return combined signals

  step_5_create_vector:
    description: "Create ActivityVector from signals"
    input: "Combined signals dict"
    output: "ActivityVector instance"
    logic: |
      Use ActivityVector.from_signals(combined_signals)

# =============================================================================
# TESTING REQUIREMENTS
# =============================================================================

testing:
  unit_tests:
    - name: "test_detect_empty_messages"
      description: "Empty input returns zero vector"

    - name: "test_detect_building_keywords"
      description: "User asking to 'implement a new feature' boosts building"

    - name: "test_detect_fixing_keywords"
      description: "User mentioning 'fix the bug' boosts fixing"

    - name: "test_detect_error_patterns"
      description: "Messages with 'error', 'exception' boost fixing"

    - name: "test_detect_config_files"
      description: "Messages mentioning .env, config.yaml boost configuring"

    - name: "test_detect_test_files"
      description: "Messages mentioning test_*.py boost testing"

    - name: "test_combined_signals"
      description: "Multiple signal sources combine correctly"

    - name: "test_signal_capping"
      description: "No dimension exceeds 1.0 after combination"

  integration_tests:
    - name: "test_with_real_session_messages"
      description: "Test with realistic SessionMessage objects"

    - name: "test_activity_vector_output"
      description: "Verify output is valid ActivityVector"

# =============================================================================
# DEPENDENCIES & INTEGRATION
# =============================================================================

dependencies:
  internal:
    - module: "graphiti_core.session_tracking.activity_vector"
      imports: ["ActivityVector"]

    - module: "graphiti_core.session_tracking.types"
      imports: ["SessionMessage", "MessageRole"]

  external:
    - package: "re"
      purpose: "Regex pattern matching for keyword/error detection"

    - package: "logging"
      purpose: "Structured logging"

integration_points:
  - target: "SessionSummarizer"
    story: "Story 11"
    description: "SessionSummarizer will call ActivityDetector.detect() to get activity vector for sessions"
    interface: |
      detector = ActivityDetector()
      activity_vector = detector.detect(session_messages)
      # activity_vector can then be added to session summary

# =============================================================================
# DISCOVERY COMPLETE
# =============================================================================

discovery_complete: true
ready_for_implementation: true
estimated_implementation_complexity: "medium"
estimated_loc: 150-200
