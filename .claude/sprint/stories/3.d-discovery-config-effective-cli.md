# Discovery: Story 3.d - CLI Command: config effective

**Status**: Complete
**Created**: 2025-12-18
**Story**: 3 - CLI Command: config effective

## Executive Summary

Completed discovery phase for Story 3 (CLI command for viewing effective configuration). Created detailed implementation plan at `.claude/sprint/plans/3-plan.yaml`. The CLI command will be implemented as a new module `config_cli.py` with its own entry point `graphiti-mcp-config` to minimize risk and maintain separation of concerns.

## Key Findings

### 1. Existing CLI Structure

**Current CLI Commands:**
- `graphiti-mcp` → Main MCP server entry point (`mcp_server.graphiti_mcp_server:main`)
- `graphiti-mcp-session-tracking` → Session tracking CLI (`mcp_server.session_tracking_cli:main`)
- `graphiti-bootstrap` → Bootstrap daemon (`mcp_server.daemon.bootstrap:main`)
- `graphiti-mcp-daemon` → Daemon manager (`mcp_server.daemon.manager:main`)

**Entry Point Definition** (pyproject.toml line 28-32):
```toml
[project.scripts]
graphiti-mcp = "mcp_server.graphiti_mcp_server:main"
graphiti-bootstrap = "mcp_server.daemon.bootstrap:main"
graphiti-mcp-daemon = "mcp_server.daemon.manager:main"
graphiti-mcp-session-tracking = "mcp_server.session_tracking_cli:main"
```

### 2. CLI Pattern Reference

**File**: `mcp_server/session_tracking_cli.py`

**Key Patterns Identified:**
- Uses `argparse` with subparsers for multiple commands
- `find_config_file()` helper searches project root then global (~/.graphiti/)
- `load_config()` / `save_config()` helpers for JSON config files
- Command functions use signature: `def cmd_name(args: argparse.Namespace) -> None`
- Status output uses symbols: `[OK]`, `[ERROR]`, `[WARNING]`, `⚠️`
- Error handling: print error message and `sys.exit(1)`
- Uses `parser.set_defaults(func=cmd_func)` to route to command handlers

**Example Command Structure** (lines 288-376):
```python
def main() -> None:
    parser = argparse.ArgumentParser(
        prog="graphiti-mcp session-tracking",
        description="Manage session tracking for Graphiti MCP server"
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    # Enable command
    enable_parser = subparsers.add_parser("enable", help="Enable automatic session tracking")
    enable_parser.set_defaults(func=cmd_enable)

    # Parse and execute
    args = parser.parse_args()
    if hasattr(args, "func"):
        args.func(args)
    else:
        parser.print_help()
        sys.exit(1)
```

### 3. Story 2 Integration Points

**Method**: `GraphitiConfig.get_effective_config(project_path: str) -> GraphitiConfig`
- **Location**: `mcp_server/unified_config.py` line 1075
- **Purpose**: Returns merged configuration (global + project override)
- **Behavior**:
  - Normalizes project_path using `normalize_project_path()`
  - Looks up path in `self.project_overrides` dict
  - If not found: returns self unchanged (global config)
  - If found: deep merges override with global config
  - Returns new GraphitiConfig instance

**Helper Functions Available:**
- `normalize_project_path(path: str) -> str` (line 1173) - Converts paths to UNIX format for consistent hashing
- `deep_merge(base: Dict, override: Dict) -> Dict` (line 1218) - Recursively merges dicts with None inheritance
- `GraphitiConfig.from_file()` - Loads config from file
- `GraphitiConfig.model_dump()` - Converts Pydantic model to dict

**Overridable Sections** (from ProjectOverride, line 838-849):
- `llm` - LLM configuration
- `embedder` - Embedder configuration
- `extraction` - Extraction configuration
- `session_tracking` - Session tracking configuration

**Non-Overridable Sections** (line 1063-1066):
- `database`, `daemon`, `resilience`, `mcp_server`, `logging`, `version`, `project`, `search`, `performance`

### 4. Output Format Requirements

**Human-Readable Format** (P0, P1):
- Header with project path
- Section-by-section display (Database, LLM, Embedder, etc.)
- Mark overridden values with `[OVERRIDE]` marker or color
- Mask sensitive values (API keys, passwords) → `***REDACTED***`
- Example:
  ```
  Effective Configuration for Project: /c/Users/Admin/myproject
  ============================================================

  LLM:
    provider: anthropic [OVERRIDE]
    default_model: claude-3-5-sonnet-20241022 [OVERRIDE]
    temperature: 0.7

  Embedder:
    provider: openai
    model: text-embedding-3-small
  ```

**Diff Format** (P1):
- Show only overridden values
- Display as "before → after" format
- Example:
  ```
  Configuration Overrides for Project: /c/Users/Admin/myproject
  ==============================================================

  LLM:
    provider: openai → anthropic
    default_model: gpt-4o → claude-3-5-sonnet-20241022
  ```

**JSON Format** (P1):
- Use `config.model_dump()` to get dict
- Output with `json.dumps(config_dict, indent=2)`
- Machine-readable for scripts/tools

**Color Support** (P2):
- Detect TTY with `sys.stdout.isatty()`
- If TTY: use ANSI codes (`\033[92m` green, `\033[93m` yellow, `\033[0m` reset)
- If not TTY: use plain text markers `[OVERRIDE]`

### 5. Implementation Approach

**Recommended Approach**: Create separate `config_cli.py` module

**Pros:**
- Clean separation of concerns
- No risk of breaking existing CLI
- Follows pattern of `session_tracking_cli.py`
- Easy to test independently

**Alternative Considered**: Add subcommand to existing `graphiti-mcp` CLI

**Rejected Because:**
- Would require refactoring `graphiti_mcp_server.py` (higher risk)
- Main CLI is for MCP server operation, not config management
- More complex implementation

### 6. Key Files and Line Numbers

**Files to Create:**
- `mcp_server/config_cli.py` (~250 lines) - New CLI module
- `tests/test_config_cli.py` (~300 lines) - Comprehensive tests

**Files to Modify:**
- `mcp_server/pyproject.toml` - Add entry point (1 line)
  - Line 32: Add `graphiti-mcp-config = "mcp_server.config_cli:main"`

**Files to Reference:**
- `mcp_server/unified_config.py` - Import GraphitiConfig, get_effective_config()
- `mcp_server/session_tracking_cli.py` - CLI pattern reference

### 7. Error Handling Requirements

**Scenarios to Handle:**
1. **Config file not found**
   - Error message: "No config file found. Run 'graphiti-mcp-session-tracking enable' to create one."
   - Exit code: 1

2. **Invalid project path**
   - Error message: "Invalid project path: {path}"
   - Exit code: 1

3. **JSON parsing error**
   - Error message: "Error parsing config file: {error}"
   - Exit code: 1

4. **No override for project**
   - Expected behavior: Show global config (not an error)

### 8. Testing Strategy

**Unit Tests** (~12 tests):
- Command line argument parsing (--project, --diff, --json)
- Default to current directory when --project not specified
- Format functions (human, diff, JSON)
- Override highlighting logic
- Sensitive value masking
- Color vs plain text output based on TTY

**Integration Tests** (~4 tests):
- End-to-end with no override → shows global config
- End-to-end with override → shows merged config
- Diff mode → shows only overrides
- JSON output → valid parseable JSON

**Edge Cases** (~4 tests):
- Missing config file
- Invalid project path
- Empty override (all None)
- Relative path handling

### 9. Dependencies

**Python Standard Library Only:**
- `argparse` - CLI parsing
- `json` - JSON output
- `sys` - Exit codes, TTY detection
- `os` - Current directory
- `pathlib` - Path handling

**Internal Imports:**
- `from mcp_server.unified_config import GraphitiConfig, normalize_project_path`

**No External Dependencies Required**

### 10. Implementation Risks

**Risk 1: Nested Config Comparison** (Medium)
- Challenge: Need to recursively compare global vs effective config
- Mitigation: Convert both to dict, compare recursively, track path for context

**Risk 2: Sensitive Value Detection** (Low)
- Challenge: Must identify and mask API keys, passwords, secrets
- Mitigation: Pattern matching on key names (api_key, password, secret, token)

**Risk 3: Color Output Compatibility** (Low)
- Challenge: ANSI codes may not work in all terminals
- Mitigation: Use sys.stdout.isatty() to detect TTY, fallback to plain text

**Risk 4: Current Directory Context** (Low)
- Challenge: User may run command from non-project directory
- Mitigation: Document behavior, use cwd as project_path (may show global config if no override)

## Recommendations

### Implementation Order

1. **Phase 1**: Create basic CLI structure
   - Create `config_cli.py` with main() and argument parsing
   - Add entry point to pyproject.toml
   - Test command execution

2. **Phase 2**: Implement effective config retrieval
   - Add cmd_effective() function
   - Call get_effective_config() with project_path
   - Test config loading and merging

3. **Phase 3**: Implement output formats
   - Add _format_config_human() with override highlighting
   - Add _format_config_diff() for diff mode
   - Add _format_config_json() for JSON output
   - Test each format

4. **Phase 4**: Add color support
   - Add TTY detection
   - Implement ANSI color codes
   - Test color vs plain text output

5. **Phase 5**: Error handling and edge cases
   - Handle missing config file
   - Handle invalid paths
   - Test edge cases

### Testing Approach

- **Unit tests first**: Test each function in isolation
- **Integration tests**: Test command execution end-to-end
- **Manual testing**: Test in real terminal with different flags
- **Platform testing**: Test on Windows (MSYS) and Unix

### Code Quality Standards

- **Type hints**: All functions must have type annotations
- **Docstrings**: All public functions must have docstrings
- **Error messages**: Must be clear and actionable
- **Exit codes**: 0 for success, 1 for errors

## Next Steps

1. Review plan file: `.claude/sprint/plans/3-plan.yaml`
2. Get approval to proceed with implementation
3. Create `config_cli.py` following plan
4. Add tests following test requirements
5. Update pyproject.toml with entry point
6. Run tests and verify CLI works as expected

## Questions for Clarification

1. **CLI naming**: Should the command be `graphiti-mcp config effective` or `graphiti-mcp-config effective`?
   - Recommendation: `graphiti-mcp-config effective` (separate entry point, cleaner)

2. **Default behavior**: What should happen if config file doesn't exist?
   - Recommendation: Print error message and exit (same as session-tracking CLI)

3. **JSON output for diff mode**: Should --json --diff output only overrides or full config?
   - Recommendation: Full effective config (diff is for human-readable output)

4. **Masking in JSON output**: Should sensitive values be masked in --json output?
   - Recommendation: Yes, consistent with security best practices

## References

- **Story 2 Plan**: `.claude/sprint/plans/2-plan.yaml`
- **Session Tracking CLI**: `mcp_server/session_tracking_cli.py`
- **Unified Config**: `mcp_server/unified_config.py`
- **Project Structure**: `mcp_server/pyproject.toml`

---

**Discovery Complete** - Ready for implementation phase.
