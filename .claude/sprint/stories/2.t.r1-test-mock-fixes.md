# Story 2.t.r1: Test Mock Fixes for Package Installation

**Type**: remediation
**Remediation Type**: bug_fix
**Parent**: Story 2.t
**Priority**: P0
**Created**: 2025-12-14

---

## Context

**Original Story**: 2.t - Testing: Package Installation to Dedicated Venv
**Current Status**: blocked
**Issue**: 24 of 28 tests failing (14% pass rate)

**Test Failures Analysis**:
1. **Missing detect_venv mock** (16 tests) - `install_package()` checks if venv exists at line 377, tests need `patch.object(manager, 'detect_venv', return_value=True)`
2. **Path.exists side_effect signature** (2 tests) - `exists_side_effect(self)` should be `exists_side_effect()` (no self parameter)
3. **Platform.system mock timing** (1 test) - Mock must be applied BEFORE creating VenvManager instance
4. **Venv existence checks** (5 tests) - `validate_installation()` checks venv exists, needs mocking

**Codebase Analysis**:
- Current implementation: `mcp_server/daemon/venv_manager.py`
- Test file: `tests/daemon/test_venv_manager.py`
- Pattern in use: unittest.mock with patch decorators and patch.object
- Integration points: VenvManager.detect_venv(), VenvManager.install_package(), VenvManager.validate_installation()

---

## Remediation Goal

Fix all 24 test failures by adding missing mocks and correcting mock signatures to achieve 100% test pass rate (28/28 tests passing).

---

## Remediation Actions

### 1. Fix Missing detect_venv Mocks in Install Tests (16 tests)

**File**: `tests/daemon/test_venv_manager.py`
**Issue**: `install_package()` calls `detect_venv()` at line 377 to verify venv exists before installing packages. Tests fail because detect_venv is not mocked.

**Changes Required**:

#### TestInstallPackage class tests (8 tests):
- `test_install_package_with_uv_pip`
- `test_install_package_with_standard_pip`
- `test_install_package_handles_nonexistent_repo`
- `test_install_package_handles_invalid_repo_path`
- `test_install_package_handles_subprocess_failure`
- `test_install_package_without_venv`
- `test_install_package_logs_subprocess_output_on_success`
- `test_install_package_logs_subprocess_output_on_failure`

**Fix Pattern**:
```python
# BEFORE (missing mock)
def test_install_package_with_uv_pip(self):
    manager = VenvManager()
    with patch.object(manager, 'get_uv_executable', return_value=Path('/venv/bin/uv')):
        # ... rest of test

# AFTER (add detect_venv mock)
def test_install_package_with_uv_pip(self):
    manager = VenvManager()
    with patch.object(manager, 'detect_venv', return_value=True), \
         patch.object(manager, 'get_uv_executable', return_value=Path('/venv/bin/uv')):
        # ... rest of test
```

**Special Case - test_install_package_without_venv**:
This test explicitly verifies behavior when venv doesn't exist, so it should mock detect_venv to return False:
```python
def test_install_package_without_venv(self):
    """VenvManager.install_package() raises VenvCreationError when venv doesn't exist"""
    manager = VenvManager()
    with patch.object(manager, 'detect_venv', return_value=False):
        with pytest.raises(VenvCreationError) as exc_info:
            manager.install_package()
        assert "Venv does not exist" in str(exc_info.value)
```

#### TestValidateInstallation class tests (8 tests):
- `test_validate_installation_with_valid_venv_and_package`
- `test_validate_installation_with_missing_venv`
- `test_validate_installation_with_missing_package`
- `test_validate_installation_with_import_failure`
- `test_validate_installation_detects_outdated_package`
- `test_validate_installation_handles_version_check_failure`
- `test_validate_installation_logs_detailed_info_on_success`
- `test_validate_installation_logs_detailed_info_on_failure`

**Fix Pattern**:
```python
# BEFORE (missing mock)
def test_validate_installation_with_valid_venv_and_package(self):
    manager = VenvManager()
    with patch.object(manager, 'get_python_executable', return_value=Path('/venv/bin/python')):
        # ... rest of test

# AFTER (add detect_venv mock)
def test_validate_installation_with_valid_venv_and_package(self):
    manager = VenvManager()
    with patch.object(manager, 'detect_venv', return_value=True), \
         patch.object(manager, 'get_python_executable', return_value=Path('/venv/bin/python')):
        # ... rest of test
```

**Special Case - test_validate_installation_with_missing_venv**:
```python
def test_validate_installation_with_missing_venv(self):
    """VenvManager.validate_installation() detects missing venv"""
    manager = VenvManager()
    with patch.object(manager, 'detect_venv', return_value=False):
        is_valid, msg = manager.validate_installation()
        assert is_valid is False
        assert "Venv does not exist" in msg
```

---

### 2. Fix Path.exists Side Effect Signature (2 tests)

**File**: `tests/daemon/test_venv_manager.py`
**Issue**: Mock side_effect functions include `self` parameter, but lambda/functions used as side_effect should not include self.

**Tests Affected**:
- `test_detect_venv_returns_true_for_existing_valid_venv`
- `test_detect_venv_returns_false_for_missing_pyvenv_cfg`

**Change**:
```python
# BEFORE (incorrect signature)
def exists_side_effect(self):
    # Check what path is being tested
    if self == mock_venv_path:
        return True
    # ... rest

# AFTER (correct signature - no self)
def exists_side_effect(path_obj):
    # path_obj is the Path instance whose .exists() was called
    if path_obj == mock_venv_path:
        return True
    # ... rest
```

**Full Fix for test_detect_venv_returns_true_for_existing_valid_venv**:
```python
def test_detect_venv_returns_true_for_existing_valid_venv(self):
    """VenvManager.detect_venv() returns True for existing valid venv"""
    manager = VenvManager()

    # Mock venv directory exists
    mock_venv_path = MagicMock(spec=Path)
    mock_venv_path.exists.return_value = True
    mock_venv_path.is_dir.return_value = True

    # Mock pyvenv.cfg exists
    mock_pyvenv_cfg = MagicMock(spec=Path)

    # Mock activate script exists (platform-specific)
    mock_activate = MagicMock(spec=Path)

    # Create side_effect function for exists() calls
    def exists_side_effect(path_obj):
        if path_obj == mock_pyvenv_cfg:
            return True
        if path_obj == mock_activate:
            return True
        return False

    # Apply mocks
    with patch.object(manager, 'venv_path', mock_venv_path), \
         patch.object(Path, '__truediv__', side_effect=[mock_pyvenv_cfg, mock_activate]), \
         patch.object(Path, 'exists', side_effect=exists_side_effect):
        assert manager.detect_venv() is True
```

---

### 3. Fix Platform.system Mock Timing (1 test)

**File**: `tests/daemon/test_venv_manager.py`
**Test**: `test_create_venv_uses_correct_python_executable_on_windows`

**Issue**: Platform.system is mocked AFTER creating VenvManager instance, but the platform check happens during method execution which uses sys.platform, not platform.system().

**Analysis**: The test is actually checking the wrong thing. Looking at the implementation:
```python
# venv_manager.py line 112-115
if sys.platform == "win32":
    activate_script = self.venv_path / "Scripts" / "activate.bat"
else:
    activate_script = self.venv_path / "bin" / "activate"
```

The code uses `sys.platform`, not `platform.system()`. The test should mock `sys.platform` instead.

**Change**:
```python
# BEFORE (mocking wrong thing)
with patch('platform.system', return_value='Windows'):
    manager = VenvManager()
    # ... test logic

# AFTER (mock sys.platform before VenvManager creation)
with patch('sys.platform', 'win32'):
    manager = VenvManager()
    # ... test logic
```

**Full Fix**:
```python
def test_create_venv_uses_correct_python_executable_on_windows(self):
    """VenvManager.create_venv() uses correct paths on Windows"""
    # Mock sys.platform BEFORE creating VenvManager
    with patch('sys.platform', 'win32'), \
         patch.object(sys, 'version_info', (3, 10, 0)):
        manager = VenvManager()

        # Mock subprocess to prevent actual venv creation
        with patch('subprocess.run') as mock_run, \
             patch.object(manager.venv_path, 'exists', return_value=False), \
             patch.object(manager, 'check_uv_available', return_value=False):

            mock_run.return_value = MagicMock(returncode=0, stdout='', stderr='')
            manager.create_venv()

            # Verify Windows paths used
            call_args = mock_run.call_args[0][0]
            # On Windows, should use sys.executable (Python.exe path)
            assert sys.executable in str(call_args)
```

---

### 4. Add Comprehensive Mock Coverage

**File**: `tests/daemon/test_venv_manager.py`

**Additional Improvements**:

1. **Ensure all venv path operations are mocked**: Any test that creates a manager instance should mock venv_path.exists() to avoid filesystem checks.

2. **Mock subprocess consistently**: All tests calling create_venv() or install_package() should mock subprocess.run to prevent actual command execution.

3. **Use context managers for multiple patches**: Combine related patches with comma-separated context managers for cleaner code.

Example pattern:
```python
def test_example(self):
    manager = VenvManager()
    with patch.object(manager, 'detect_venv', return_value=True), \
         patch.object(manager, 'get_uv_executable', return_value=Path('/venv/bin/uv')), \
         patch('subprocess.run') as mock_run:
        mock_run.return_value = MagicMock(returncode=0)
        # ... test logic
```

---

## Testing

**Test Execution**:
```bash
cd C:/Users/Admin/Documents/GitHub/graphiti
python -m pytest tests/daemon/test_venv_manager.py -v
```

**Expected Results**:
- All 28 tests passing (100% pass rate)
- No VenvCreationError exceptions from missing venv
- No AttributeError from incorrect side_effect signatures
- No platform-related failures

**Verification Commands**:
```bash
# Run full test suite
python -m pytest tests/daemon/test_venv_manager.py -v

# Run specific test classes
python -m pytest tests/daemon/test_venv_manager.py::TestInstallPackage -v
python -m pytest tests/daemon/test_venv_manager.py::TestValidateInstallation -v

# Show detailed failure info
python -m pytest tests/daemon/test_venv_manager.py -vv --tb=short
```

---

## Acceptance Criteria

- [ ] **(P0) AC-2.t.r1.1**: All 16 install/validate tests pass with correct detect_venv mocks
- [ ] **(P0) AC-2.t.r1.2**: Both Path.exists side_effect tests pass with correct function signatures
- [ ] **(P0) AC-2.t.r1.3**: Platform-specific test passes with correct sys.platform mock timing
- [ ] **(P0) AC-2.t.r1.4**: Full test suite achieves 100% pass rate (28/28 tests passing)
- [ ] **(P0) AC-2.t.r1.5**: No VenvCreationError exceptions from missing mocks
- [ ] **(P0) AC-2.t.r1.6**: No AttributeError from incorrect mock signatures

---

## Verification

1. **Run test suite**: Execute `pytest tests/daemon/test_venv_manager.py -v` and verify 28/28 passing
2. **Check test output**: Verify no VenvCreationError or AttributeError in output
3. **Validate test coverage**: Each failure category addressed:
   - 16 detect_venv mocks added
   - 2 side_effect signatures fixed
   - 1 platform mock timing fixed
4. **Integration check**: Verify tests accurately reflect VenvManager behavior from implementation

---

## Notes

- **Remediation Type**: bug_fix
- **Auto-Created**: 2025-12-14T12:00:00Z
- **Created From**: Natural language request
- **Original Request**: "Story 2.t failed with a 14% test pass rate (24 of 28 tests failed). Create a remediation story and fix the issues."
- **Root Cause**: Missing mocks for venv existence checks that were added in implementation but not reflected in tests
- **Impact**: Test suite not accurately validating package installation behavior
- **Risk**: Low - test-only changes, no production code affected

---

**Created**: 2025-12-14T12:00:00Z
