# Story -4.t.1: Fix Schema Mismatch in Reconciliation Metadata

**Type**: remediation
**Remediation Type**: validation_failure
**Parent**: Story -4.t (Validate Testing: Reconciliation Application Functions)
**Priority**: P0
**Created**: 2025-12-20

---

## Context

**Original Story**: -4.t - Validate Testing: Reconciliation Application Functions
**Current Status**: unassigned
**Issue**: Schema mismatch between validation schema and implementation

**Validation Failure**: The `validate_reconciliation()` schema in `test_reconciliation_schemas.py` expects a required `remediation_count` field, but the `apply_*_reconciliation()` functions in `reconciliation.py` don't include this field in their metadata dictionaries.

**Codebase Analysis**:
- Schema validation: `tests/sprint/test_reconciliation_schemas.py`
  - Line 166: Error message "Missing required field: remediation_count"
  - Line 288: Field definition shows `remediation_count` is required
- Implementation: `resources/commands/sprint/queue_helpers/reconciliation.py`
  - Three functions return reconciliation metadata without `remediation_count`:
    - `apply_propagate_reconciliation()` (lines 103-113)
    - `apply_retest_reconciliation()` (lines 232-238)
    - `apply_supersede_reconciliation()` (lines 348-353)

---

## Remediation Goal

Align reconciliation metadata structure between validation schema and implementation by adding the `remediation_count` field to all reconciliation metadata dictionaries returned by the `apply_*_reconciliation()` functions.

---

## Remediation Actions

### 1. Add `remediation_count` to `apply_propagate_reconciliation()`

**File**: `resources/commands/sprint/queue_helpers/reconciliation.py`
**Change**: Add `remediation_count` field to reconciliation metadata dictionary (lines 103-113)

**Current code** (lines 103-113):
```python
reconciliation_metadata = {
    'status': 'propagated',
    'source_story': source_remediation_id,
    'source_pass_rate': pass_rate,
    'source_test_count': test_count,
    'applied_at': datetime.utcnow().isoformat(),
    'propagation_note': (
        f"Pass propagated from {source_remediation_id} "
        f"({pass_rate:.1f}% pass rate, {passed}/{total} tests)"
    )
}
```

**Updated code**:
```python
reconciliation_metadata = {
    'status': 'propagated',
    'source_story': source_remediation_id,
    'source_pass_rate': pass_rate,
    'source_test_count': test_count,
    'remediation_count': 1,  # Single remediation story triggered this reconciliation
    'applied_at': datetime.utcnow().isoformat(),
    'propagation_note': (
        f"Pass propagated from {source_remediation_id} "
        f"({pass_rate:.1f}% pass rate, {passed}/{total} tests)"
    )
}
```

**Rationale**: The `remediation_count` represents the number of remediation stories associated with this reconciliation. For propagate mode, this is always 1 (the source remediation story that triggered the reconciliation).

---

### 2. Add `remediation_count` to `apply_retest_reconciliation()`

**File**: `resources/commands/sprint/queue_helpers/reconciliation.py`
**Change**: Add `remediation_count` field to reconciliation metadata dictionary (lines 232-238)

**Current code** (lines 232-238):
```python
reconciliation_metadata = {
    'status': 'pending_retest',
    'source_story': source_remediation_id,
    'needs_retest': True,
    'retest_reason': retest_reason,
    'applied_at': datetime.utcnow().isoformat()
}
```

**Updated code**:
```python
reconciliation_metadata = {
    'status': 'pending_retest',
    'source_story': source_remediation_id,
    'needs_retest': True,
    'retest_reason': retest_reason,
    'remediation_count': 1,  # Single remediation story triggered this reconciliation
    'applied_at': datetime.utcnow().isoformat()
}
```

**Rationale**: Same as above - single remediation story triggers retest reconciliation.

---

### 3. Add `remediation_count` to `apply_supersede_reconciliation()`

**File**: `resources/commands/sprint/queue_helpers/reconciliation.py`
**Change**: Add `remediation_count` field to reconciliation metadata dictionary (lines 348-353)

**Current code** (lines 348-353):
```python
reconciliation_metadata = {
    'status': 'superseded',
    'superseded_by': source_remediation_id,
    'supersession_reason': supersession_reason,
    'applied_at': datetime.utcnow().isoformat()
}
```

**Updated code**:
```python
reconciliation_metadata = {
    'status': 'superseded',
    'superseded_by': source_remediation_id,
    'supersession_reason': supersession_reason,
    'remediation_count': 1,  # Single remediation story supersedes this validation
    'applied_at': datetime.utcnow().isoformat()
}
```

**Rationale**: Single remediation story supersedes the validation, so count is 1.

---

## Testing

**Existing Tests to Verify**:

1. **Schema Validation Tests** (`tests/sprint/test_reconciliation_schemas.py`):
   - `test_reconciliation_missing_remediation_count` (line 160-166) - Should now PASS
   - `test_reconciliation_invalid_remediation_count_type` (line 168-177) - Ensures int type
   - `test_reconciliation_negative_remediation_count` (line 177-186) - Ensures non-negative

2. **Integration Tests** (`tests/sprint/test_reconciliation_integration.py`):
   - Lines 143, 279: Tests that use `remediation_count: 3` should still work
   - Line 200-202: Invalid type test should continue to fail validation

3. **Function Tests** (`tests/sprint/test_reconciliation_application.py`):
   - All tests that call `apply_propagate_reconciliation()`, `apply_retest_reconciliation()`, or `apply_supersede_reconciliation()` should verify the returned metadata includes `remediation_count`

**New Verification**:
```python
# Verify each apply_* function returns remediation_count
def test_propagate_includes_remediation_count():
    result = apply_propagate_reconciliation(...)
    metadata = result['reconciliation']
    assert 'remediation_count' in metadata
    assert metadata['remediation_count'] == 1
    assert isinstance(metadata['remediation_count'], int)

def test_retest_includes_remediation_count():
    result = apply_retest_reconciliation(...)
    metadata = result['reconciliation']
    assert 'remediation_count' in metadata
    assert metadata['remediation_count'] == 1
    assert isinstance(metadata['remediation_count'], int)

def test_supersede_includes_remediation_count():
    result = apply_supersede_reconciliation(...)
    metadata = result['reconciliation']
    assert 'remediation_count' in metadata
    assert metadata['remediation_count'] == 1
    assert isinstance(metadata['remediation_count'], int)
```

---

## Acceptance Criteria

- [ ] **(P0) AC--4.t.1.1**: All three `apply_*_reconciliation()` functions include `remediation_count: 1` in their metadata dictionaries
- [ ] **(P0) AC--4.t.1.2**: Schema validation test `test_reconciliation_missing_remediation_count` passes without errors
- [ ] **(P0) AC--4.t.1.3**: All existing reconciliation integration tests pass with the new field
- [ ] **(P0) AC--4.t.1.4**: Type validation for `remediation_count` ensures it's an integer >= 0
- [ ] **(P0) AC--4.t.1.5**: No regressions in existing reconciliation functionality

---

## Verification

1. Run schema validation tests:
   ```bash
   pytest tests/sprint/test_reconciliation_schemas.py::test_reconciliation_missing_remediation_count -v
   pytest tests/sprint/test_reconciliation_schemas.py::test_reconciliation_invalid_remediation_count_type -v
   pytest tests/sprint/test_reconciliation_schemas.py::test_reconciliation_negative_remediation_count -v
   ```
   Expected: All tests PASS

2. Run integration tests:
   ```bash
   pytest tests/sprint/test_reconciliation_integration.py -v
   ```
   Expected: All tests PASS

3. Run application tests:
   ```bash
   pytest tests/sprint/test_reconciliation_application.py -v
   ```
   Expected: All tests PASS, metadata includes `remediation_count`

4. Verify metadata structure:
   - Each reconciliation metadata dict has exactly 6-7 fields (depending on reconciliation type)
   - `remediation_count` is present and is integer value 1
   - All other existing fields are unchanged

---

## Implementation Notes

**Design Decision**: Setting `remediation_count` to 1 for all three functions

- **Current behavior**: Each reconciliation is triggered by a single remediation story completing its tests
- **Assumption**: The relationship is 1:1 (one remediation story → one reconciliation action)
- **Future enhancement**: If batch reconciliation is implemented (multiple remediations → single validation reconciliation), this field should be updated to reflect the actual count

**Alternative Considered**: Making `remediation_count` an optional parameter
- **Rejected**: The schema requires this field, and the current workflow always has a single source remediation
- **If needed later**: Could add parameter with default value of 1

**Field Placement**: Added after `source_story`/`superseded_by` field for consistency across all three functions

---

## Notes

- **Remediation Type**: validation_failure
- **Auto-Created**: 2025-12-20
- **Created From**: Validation failure in Story -4.t
- **Source Validation**: -4.t
- **Original Request**: "Align reconciliation metadata between validation schema (test_reconciliation.py) and implementation functions (reconciliation.py). Add required remediation_count field or update schema to match implementation."

---

**Created**: 2025-12-20T00:00:00Z
