# Plan: Story 5 - Graphiti Storage Integration
# Generated by: discovery:5.d
# Timestamp: 2025-12-09T08:35:00Z

story_id: "5"
title: "Graphiti Storage Integration"
created: "2025-12-09T08:35:00Z"
created_by: "discovery:5.d"

# Analysis Summary
analysis:
  summary: "Modify store_session() to accept namespace metadata parameters and prepend YAML frontmatter header to episode body. Update source_description to include namespace prefix."
  complexity: "medium"
  estimated_files: 1
  estimated_tokens: 8000
  risk_factors:
    - "Backward compatibility - existing callers don't pass new params"
    - "Integration with build_episode_metadata_header from Story 4"
    - "Missing message_count/session_file data in SessionSummary"

# Files to Create
files_to_create: []

# Files to Modify
files_to_modify:
  - path: "graphiti_core/session_tracking/graphiti_storage.py"
    changes:
      - "Import build_episode_metadata_header from .metadata"
      - "Import socket module for hostname fallback"
      - "Add new parameters to store_session() signature: project_namespace, project_path, hostname, include_project_path, session_file, message_count"
      - "Build metadata header when project_namespace is provided"
      - "Prepend metadata header to episode_body"
      - "Update source_description format to include namespace prefix"
      - "Add backward compatibility: skip metadata header if project_namespace is None"
      - "Add logging for namespace/metadata operations"
    lines_affected: 40

# Integration Points
integration:
  - file: "graphiti_core/session_tracking/metadata.py"
    type: "import"
    description: "Import build_episode_metadata_header function from Story 4 implementation"

# Patterns to Follow
patterns:
  - source: "graphiti_core/session_tracking/metadata.py"
    pattern: "build_episode_metadata_header() function signature and return format"
  - source: "graphiti_core/session_tracking/graphiti_storage.py"
    pattern: "Existing store_session() structure, logging patterns, error handling"

# Test Requirements
test_requirements:
  unit:
    - "Test store_session with all new parameters provided"
    - "Test store_session with project_namespace=None (backward compatibility)"
    - "Test store_session with include_project_path=False"
    - "Test store_session with hostname=None (uses socket.gethostname())"
    - "Test that metadata header is correctly prepended to episode_body"
    - "Test that source_description includes namespace prefix"
  integration:
    - "Test end-to-end session storage with metadata in mock Graphiti"
    - "Test that stored episode body contains valid YAML frontmatter"
  security: []

# Acceptance Criteria Mapping
acceptance_criteria:
  - id: "AC-5.1"
    text: "(P0) store_session() accepts new parameters: project_namespace, project_path, hostname, include_project_path"
    implementation: "files_to_modify[0] - Add parameters to function signature"
    tests: "test_requirements.unit[0-3]"

  - id: "AC-5.2"
    text: "(P0) Metadata header prepended to episode body"
    implementation: "files_to_modify[0] - Call build_episode_metadata_header and prepend to episode_body"
    tests: "test_requirements.unit[4], test_requirements.integration[1]"

  - id: "AC-5.3"
    text: "(P0) source_description prefixed with [{namespace[:8]}]"
    implementation: "files_to_modify[0] - Update source_description format string"
    tests: "test_requirements.unit[5]"

  - id: "AC-5.4"
    text: "(P1) Episodes stored with global group_id (not project-specific)"
    implementation: "files_to_modify[0] - group_id parameter already exists, no change needed"
    tests: "Covered by existing group_id tests"

  - id: "AC-5.5"
    text: "(P1) Backward compatibility: function works if new params not provided"
    implementation: "files_to_modify[0] - Default project_namespace to None, skip metadata if None"
    tests: "test_requirements.unit[1]"

# Implementation Details
implementation_details:
  new_function_signature: |
    async def store_session(
        self,
        summary: SessionSummary,
        group_id: str,
        project_namespace: str | None = None,  # NEW - optional for backward compat
        project_path: str | None = None,  # NEW
        hostname: str | None = None,  # NEW - defaults to socket.gethostname()
        include_project_path: bool = True,  # NEW
        session_file: str | None = None,  # NEW - for metadata header
        message_count: int | None = None,  # NEW - for metadata header
        previous_session_uuid: str | None = None,
        handoff_file_path: Path | None = None,
    ) -> str:

  metadata_header_logic: |
    # Build metadata header (only if namespace provided)
    if project_namespace is not None:
        # Use provided values or sensible defaults
        effective_hostname = hostname or socket.gethostname()
        effective_session_file = session_file or f"session-{summary.slug}.jsonl"
        effective_message_count = message_count or 0

        # Calculate duration from summary's duration_estimate
        duration_minutes = 0
        if summary.duration_estimate:
            # Parse "~Xh" or "~Xm" format
            try:
                if 'h' in summary.duration_estimate:
                    duration_minutes = int(summary.duration_estimate.replace('~', '').replace('h', '')) * 60
                elif 'm' in summary.duration_estimate:
                    duration_minutes = int(summary.duration_estimate.replace('~', '').replace('m', ''))
            except ValueError:
                duration_minutes = 0

        metadata_header = build_episode_metadata_header(
            project_namespace=project_namespace,
            project_path=project_path,
            hostname=effective_hostname,
            session_file=effective_session_file,
            message_count=effective_message_count,
            duration_minutes=duration_minutes,
            include_project_path=include_project_path,
        )
        episode_body = metadata_header + summary.to_markdown()
    else:
        # Backward compatibility: no metadata header
        episode_body = summary.to_markdown()

  source_description_format: |
    # Prefix source description with namespace (if provided)
    if project_namespace is not None:
        source_description = (
            f"[{project_namespace[:8]}] "
            f"Session handoff summary with {len(summary.completed_tasks)} completed tasks, "
            f"{len(summary.blocked_items)} blocked items, "
            f"and {len(summary.files_modified)} files modified"
        )
    else:
        source_description = (
            f"Session handoff summary with {len(summary.completed_tasks)} completed tasks, "
            f"{len(summary.blocked_items)} blocked items, "
            f"and {len(summary.files_modified)} files modified"
        )

# Notes for Implementation Phase
notes:
  - "Story 4 (Episode Metadata Builder) is complete - build_episode_metadata_header is available"
  - "SessionSummary doesn't have message_count or session_file - these must be passed by caller (Story 6)"
  - "duration_estimate in SessionSummary is a string like '~2h' - needs parsing for duration_minutes"
  - "Keep all new parameters optional with sensible defaults for backward compatibility"
  - "Story 6 (Session Manager Updates) depends on this story being complete"
