# Plan: Story 7 - MCP Server Search Filter Implementation
# Generated by: discovery:7.d
# Timestamp: 2025-12-09T17:00:00Z

story_id: "7"
title: "MCP Server Search Filter Implementation"
created: "2025-12-09T17:00:00Z"
created_by: "discovery:7.d"

# Analysis Summary
analysis:
  summary: "Modify search_memory_nodes and search_memory_facts to use global group_id by default and add post-filtering by project namespace based on SessionTrackingConfig settings (cross_project_search, trusted_namespaces)."
  complexity: "medium"
  estimated_files: 1
  estimated_tokens: 4000
  risk_factors:
    - "Namespace extraction from YAML frontmatter adds processing overhead"
    - "Post-filtering reduces result count (may need to over-fetch)"
    - "Need to handle content without frontmatter gracefully"

# Dependencies Analysis
dependencies:
  upstream:
    - story_id: "1"
      title: "Configuration Schema Updates"
      status: "completed"
      provides:
        - "SessionTrackingConfig with group_id, cross_project_search, trusted_namespaces"
    - story_id: "5"
      title: "Graphiti Storage Integration"
      status: "completed"
      provides:
        - "Episodes with YAML frontmatter containing project_namespace"
    - story_id: "6"
      title: "Session Manager Updates"
      status: "completed"
      provides:
        - "Sessions indexed with namespace metadata in episode content"
  downstream:
    - story_id: "9"
      title: "Integration Tests for Cross-Project Search"
      uses: "Namespace filtering in search tools"

# Files to Create
files_to_create:
  - path: "mcp_server/namespace_filter.py"
    purpose: "Helper functions for namespace extraction and filtering of search results"
    pattern_source: "graphiti_core/session_tracking/metadata.py"
    estimated_lines: 80
    contents:
      - "extract_namespace_from_content(content: str) -> Optional[str]"
      - "filter_by_namespace(results: List[T], namespaces: List[str]) -> List[T]"
      - "get_effective_group_id(config: SessionTrackingConfig) -> str"

# Files to Modify
files_to_modify:
  - path: "mcp_server/graphiti_mcp_server.py"
    changes:
      - "Import namespace_filter module"
      - "Add socket import (if not present)"
      - "Modify search_memory_nodes: add project_namespaces parameter"
      - "Modify search_memory_nodes: use global group_id from config or compute"
      - "Modify search_memory_nodes: add post-filtering by namespace"
      - "Modify search_memory_facts: add project_namespaces parameter"
      - "Modify search_memory_facts: use global group_id from config or compute"
      - "Modify search_memory_facts: add post-filtering by namespace"
    lines_affected: 100

# Integration Points
integration:
  - file: "mcp_server/graphiti_mcp_server.py"
    type: "import"
    description: "Import namespace_filter module and socket module"
  - file: "mcp_server/graphiti_mcp_server.py"
    type: "config"
    description: "Access unified_config.session_tracking for namespace settings"

# Patterns to Follow
patterns:
  - source: "graphiti_core/session_tracking/metadata.py:15-104"
    pattern: "YAML frontmatter parsing structure (inverse of build_episode_metadata_header)"
  - source: "mcp_server/graphiti_mcp_server.py:1466-1470"
    pattern: "Current effective_group_ids logic - extend to use global group_id"
  - source: "mcp_server/graphiti_mcp_server.py:2591-2595"
    pattern: "Global group_id computation in session tracking callback"

# Implementation Details
implementation:
  namespace_filter_module:
    description: "New module with namespace filtering utilities"
    location: "mcp_server/namespace_filter.py"
    functions:
      extract_namespace_from_content:
        signature: "def extract_namespace_from_content(content: str) -> Optional[str]"
        logic: |
          """Extract project_namespace from YAML frontmatter in episode content.

          Parses the YAML frontmatter at the start of episode content to extract
          the project_namespace field from graphiti_session_metadata.

          Args:
              content: Episode content string, potentially with YAML frontmatter

          Returns:
              Project namespace string, or None if not found or parsing fails
          """
          if not content or not content.startswith('---'):
              return None

          try:
              # Find end of frontmatter
              end_idx = content.index('---', 3)
              frontmatter_str = content[3:end_idx]

              # Parse YAML
              import yaml
              frontmatter = yaml.safe_load(frontmatter_str)

              # Extract namespace
              if frontmatter and 'graphiti_session_metadata' in frontmatter:
                  return frontmatter['graphiti_session_metadata'].get('project_namespace')

              return None
          except (ValueError, yaml.YAMLError):
              return None

      filter_by_namespace:
        signature: |
          def filter_by_namespace(
              results: List[Any],
              namespaces: List[str],
              content_attr: str = 'content'
          ) -> List[Any]
        logic: |
          """Filter search results to only include specified namespaces.

          Post-filters search results by extracting project_namespace from each
          result's content and checking against the allowed namespaces list.

          Args:
              results: List of search result objects
              namespaces: List of allowed namespace hashes
              content_attr: Attribute name containing content (default: 'content')

          Returns:
              Filtered list containing only results from specified namespaces
          """
          if not namespaces:
              return results

          filtered = []
          for result in results:
              # Get content from result object
              content = getattr(result, content_attr, None)
              if content is None:
                  continue

              # Extract namespace from content
              ns = extract_namespace_from_content(content)

              # Include if namespace matches or no namespace (backward compat)
              if ns is None or ns in namespaces:
                  filtered.append(result)

          return filtered

      get_effective_group_id:
        signature: "def get_effective_group_id(config: 'SessionTrackingConfig') -> str"
        logic: |
          """Get the effective global group ID from config.

          Returns the configured group_id, or computes default based on hostname.

          Args:
              config: SessionTrackingConfig instance

          Returns:
              Group ID string (e.g., 'HOSTNAME__global')
          """
          import socket

          if config.group_id:
              return config.group_id

          hostname = socket.gethostname()
          return f"{hostname}__global"

  search_memory_nodes_changes:
    description: "Modifications to search_memory_nodes function"
    changes:
      - name: "Add project_namespaces parameter"
        signature_addition: "project_namespaces: list[str] | None = None"
        docstring_addition: |
          project_namespaces: Optional filter for specific project namespaces.
              If None, uses config settings (cross_project_search, trusted_namespaces).
              If provided, overrides config and filters to specified namespaces only.

      - name: "Modify effective_group_ids computation"
        current: |
          effective_group_ids = (
              group_ids if group_ids is not None else [config.group_id] if config.group_id else []
          )
        new: |
          # Determine effective group_ids using global session tracking config
          if group_ids is not None:
              effective_group_ids = group_ids
          else:
              # Use global group_id from session tracking config
              from mcp_server.namespace_filter import get_effective_group_id
              st_config = unified_config.session_tracking
              global_group = get_effective_group_id(st_config)
              effective_group_ids = [global_group]

      - name: "Add namespace post-filtering"
        location: "After search_results = await client._search(...)"
        new_code: |
          # Determine effective namespace filter
          from mcp_server.namespace_filter import filter_by_namespace, extract_namespace_from_content
          st_config = unified_config.session_tracking

          effective_namespaces = project_namespaces
          if effective_namespaces is None:
              if not st_config.cross_project_search:
                  # Would need current project namespace - log warning if not available
                  logger.warning(
                      "cross_project_search is False but no project_namespaces provided. "
                      "Results may include all namespaces."
                  )
              elif st_config.trusted_namespaces:
                  effective_namespaces = st_config.trusted_namespaces

          # Post-filter results by namespace if specified
          if effective_namespaces and search_results.nodes:
              # For nodes, namespace is in associated episode content
              # We need to filter based on node attributes or summary
              # Note: May need to enhance this if namespace not in node directly
              filtered_nodes = []
              for node in search_results.nodes:
                  # Try to extract namespace from summary or attributes
                  ns = None
                  if hasattr(node, 'summary') and node.summary:
                      ns = extract_namespace_from_content(node.summary)
                  if ns is None and hasattr(node, 'attributes'):
                      ns = node.attributes.get('project_namespace')

                  # Include if matches or no namespace found (backward compat)
                  if ns is None or ns in effective_namespaces:
                      filtered_nodes.append(node)

              # Create new results with filtered nodes
              from dataclasses import replace
              search_results = replace(search_results, nodes=filtered_nodes)

  search_memory_facts_changes:
    description: "Modifications to search_memory_facts function"
    changes:
      - name: "Add project_namespaces parameter"
        signature_addition: "project_namespaces: list[str] | None = None"

      - name: "Modify effective_group_ids computation"
        same_as: "search_memory_nodes_changes"

      - name: "Add namespace post-filtering"
        location: "After relevant_edges = await client.search(...)"
        new_code: |
          # Determine effective namespace filter
          from mcp_server.namespace_filter import filter_by_namespace
          st_config = unified_config.session_tracking

          effective_namespaces = project_namespaces
          if effective_namespaces is None:
              if not st_config.cross_project_search:
                  logger.warning(
                      "cross_project_search is False but no project_namespaces provided."
                  )
              elif st_config.trusted_namespaces:
                  effective_namespaces = st_config.trusted_namespaces

          # Post-filter edges by namespace if specified
          if effective_namespaces and relevant_edges:
              # Edges have fact attribute with content
              filtered_edges = filter_by_namespace(
                  relevant_edges,
                  effective_namespaces,
                  content_attr='fact'
              )
              relevant_edges = filtered_edges

# Test Requirements
test_requirements:
  unit:
    - name: "test_extract_namespace_from_content_valid"
      description: "Extract namespace from valid YAML frontmatter"
      assertions:
        - "Returns 'a1b2c3d4' from valid frontmatter"
    - name: "test_extract_namespace_from_content_no_frontmatter"
      description: "Handle content without YAML frontmatter"
      assertions:
        - "Returns None for plain text content"
    - name: "test_extract_namespace_from_content_invalid_yaml"
      description: "Handle malformed YAML gracefully"
      assertions:
        - "Returns None without raising exception"
    - name: "test_filter_by_namespace_single"
      description: "Filter to single namespace"
      assertions:
        - "Only results with matching namespace returned"
    - name: "test_filter_by_namespace_multiple"
      description: "Filter to multiple namespaces"
      assertions:
        - "Results from any of the namespaces returned"
    - name: "test_filter_by_namespace_empty_list"
      description: "Empty namespace list returns all results"
      assertions:
        - "All input results returned unchanged"
    - name: "test_get_effective_group_id_from_config"
      description: "Use configured group_id"
      assertions:
        - "Returns config.group_id when set"
    - name: "test_get_effective_group_id_computed"
      description: "Compute default when not configured"
      assertions:
        - "Returns '{hostname}__global' format"
    - name: "test_search_memory_nodes_uses_global_group_id"
      description: "search_memory_nodes uses global group_id by default"
      assertions:
        - "Passes global group_id to graphiti._search()"
    - name: "test_search_memory_nodes_explicit_namespaces"
      description: "Explicit project_namespaces parameter filters results"
      assertions:
        - "Only specified namespaces in results"
    - name: "test_search_memory_nodes_trusted_namespaces"
      description: "Config trusted_namespaces filters results"
      assertions:
        - "Only trusted namespaces in results"
  integration:
    - name: "test_cross_project_search_returns_all"
      description: "With cross_project_search=true, returns results from all projects"
      setup: "Index sessions from projectA and projectB"
      assertions:
        - "Results include sessions from both projects"
        - "Namespace metadata visible in results"
    - name: "test_cross_project_search_disabled_requires_namespaces"
      description: "With cross_project_search=false and project_namespaces provided, filters correctly"
      setup: "Index sessions from projectA and projectB"
      assertions:
        - "Only results from specified namespace returned"
    - name: "test_trusted_namespaces_excludes_untrusted"
      description: "Only trusted namespaces appear in results"
      setup: "Index from trusted and untrusted namespaces"
      assertions:
        - "Untrusted namespace results excluded"
  security:
    - name: "test_namespace_extraction_prevents_injection"
      description: "Malformed YAML doesn't cause security issues"
      assertions:
        - "No code execution from malicious YAML"
        - "Returns None for suspicious content"

# Acceptance Criteria Mapping
acceptance_criteria:
  - id: "AC-7.1"
    priority: "P0"
    text: "search_memory_nodes uses global group_id by default"
    implementation: "Modify effective_group_ids computation in search_memory_nodes"
    tests: "test_search_memory_nodes_uses_global_group_id"

  - id: "AC-7.2"
    priority: "P0"
    text: "If cross_project_search: false, auto-filters to current namespace"
    implementation: "Add post-filter logic using project_namespaces parameter"
    tests: "test_cross_project_search_disabled_requires_namespaces"
    notes: "Requires caller to provide project_namespaces when cross_project_search is false"

  - id: "AC-7.3"
    priority: "P1"
    text: "If trusted_namespaces configured, filters results to trusted only"
    implementation: "Add post-filter using unified_config.session_tracking.trusted_namespaces"
    tests: "test_trusted_namespaces_excludes_untrusted, test_search_memory_nodes_trusted_namespaces"

  - id: "AC-7.4"
    priority: "P1"
    text: "Post-filtering implemented until Graphiti supports native metadata filtering"
    implementation: "Create filter_by_namespace() and extract_namespace_from_content() helpers"
    tests: "test_filter_by_namespace_*, test_extract_namespace_from_content_*"

  - id: "AC-7.5"
    priority: "P0"
    text: "Namespace metadata visible in search results"
    implementation: "No change needed - metadata already in episode content via Story 5/6"
    tests: "test_cross_project_search_returns_all (verify metadata present)"
    notes: "Verify existing implementation includes namespace in returned content"

# Notes for Implementation Phase
notes:
  - "The namespace_filter module should be created first as it's used by both search functions"
  - "For nodes, namespace may be in summary text or attributes - check both"
  - "For edges/facts, namespace is typically in the fact content"
  - "When cross_project_search=false and no project_namespaces provided, log warning but return results"
  - "Consider over-fetching (max_nodes * 2) then filtering to ensure enough results after filter"
  - "yaml.safe_load is safe against arbitrary code execution"
  - "The effective_group_id computation mirrors Story 6's implementation in on_session_closed"
