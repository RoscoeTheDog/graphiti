# Plan: 3
# Generated by: discovery:3.d
# Timestamp: 2025-12-23T23:30:00Z

story_id: "3"
title: "Update venv_manager to use deployed package"
created: "2025-12-23T23:30:00Z"
created_by: "discovery:3.d"

# Analysis Summary
analysis:
  summary: "Modify venv_manager.py install_package() method to install dependencies from ~/.graphiti/requirements.txt using uv pip or pip, replacing the current repository-based installation approach."
  complexity: "medium"
  estimated_files: 2
  estimated_tokens: 6000
  risk_factors:
    - "Must maintain backward compatibility for development scenarios"
    - "uvx vs uv pip command differences and availability detection"
    - "Error handling if requirements.txt is missing or malformed"
    - "Validation that mcp_server is importable after installation"

# Files to Modify
files_to_modify:
  - path: "mcp_server/daemon/venv_manager.py"
    changes:
      - "Modify install_package() to install from ~/.graphiti/requirements.txt instead of repository"
      - "Update tool detection: check for uvx first, then uv pip, finally fall back to pip"
      - "Change installation command from 'pip install ./mcp_server' to 'pip install -r ~/.graphiti/requirements.txt'"
      - "Add validation to check if requirements.txt exists before attempting installation"
      - "Update error messages to reference ~/.graphiti/requirements.txt location"
      - "Remove detect_repo_location() dependency from install_package() (keep method for other uses)"
      - "Update logging to indicate installation from requirements.txt"
    lines_affected: 30
    context:
      - "Current implementation: install_package() detects repo location, validates mcp_server/ path, installs with 'pip install ./mcp_server'"
      - "New implementation: Check ~/.graphiti/requirements.txt exists, install with 'pip install -r ~/.graphiti/requirements.txt'"
      - "Tool preference order: uvx (if available) → uv pip (if available) → standard pip"
      - "Maintain existing validation: validate_installation('mcp_server') still runs after install"

  - path: "mcp_server/daemon/tests/test_venv_manager.py"
    changes:
      - "Update test_install_package() to mock ~/.graphiti/requirements.txt existence"
      - "Add test_install_package_missing_requirements_txt() for error handling"
      - "Update mocked subprocess calls to expect 'pip install -r ~/.graphiti/requirements.txt'"
      - "Add test_install_package_with_uvx() to test uvx installation path"
      - "Add test_install_package_with_uv_pip() to test uv pip installation path"
      - "Update test fixtures to create temporary requirements.txt in test environment"
    lines_affected: 40
    context:
      - "Current tests mock repository detection and pip install ./mcp_server"
      - "New tests should mock ~/.graphiti/requirements.txt and verify correct pip command"

# Integration Points
integration:
  - file: "mcp_server/daemon/manager.py"
    type: "dependency"
    description: "DaemonManager.install() calls venv_manager.install_package() - no changes needed to manager.py"

  - file: "mcp_server/daemon/generate_requirements.py"
    type: "dependency"
    description: "Assumes requirements.txt was generated by Story 1 and exists at ~/.graphiti/requirements.txt"

  - file: "mcp_server/daemon/package_deployer.py"
    type: "dependency"
    description: "Package deployer (Story 2) should have deployed requirements.txt before install_package() is called"

# Patterns to Follow
patterns:
  - source: "mcp_server/daemon/venv_manager.py"
    pattern: "Platform-agnostic path handling using Path.home() / '.graphiti' / 'requirements.txt'"

  - source: "mcp_server/daemon/venv_manager.py"
    pattern: "Return Tuple[bool, str] for operation results with user-friendly error messages"

  - source: "mcp_server/daemon/venv_manager.py"
    pattern: "Tool detection with fallback: check_uv_available() → get_uv_executable() → get_pip_executable()"

  - source: "mcp_server/daemon/venv_manager.py"
    pattern: "Subprocess execution with timeout (300s), error capture, and validation"

# Test Requirements
test_requirements:
  unit:
    - "Test install_package() with uvx available (preferred tool)"
    - "Test install_package() with uv pip available (secondary tool)"
    - "Test install_package() with standard pip only (fallback)"
    - "Test install_package() raises error if requirements.txt missing"
    - "Test install_package() validates mcp_server is importable after installation"
    - "Test install_package() returns proper error message if installation fails"
    - "Test install_package() uses correct command: 'pip install -r ~/.graphiti/requirements.txt'"
    - "Test path resolution uses Path.home() for cross-platform compatibility"

  integration:
    - "Test install_package() with real ~/.graphiti/requirements.txt file"
    - "Test full workflow: create venv → install from requirements.txt → validate importable"
    - "Test error recovery when requirements.txt is malformed"
    - "Test installation works on Windows and Unix platforms"

  security:
    - "Test requirements.txt path validation (prevent path traversal)"
    - "Test command injection prevention in subprocess calls"
    - "Test handling of malicious requirements.txt content"

# Acceptance Criteria Mapping
acceptance_criteria:
  - id: "AC-3.1"
    text: "(P0) install_package() installs from ~/.graphiti/requirements.txt"
    implementation: "files_to_modify[0] - Change install command to use requirements.txt"
    tests: "test_requirements.unit[6], integration[0,1]"

  - id: "AC-3.2"
    text: "(P0) Uses uvx when available, falls back to uv pip or pip"
    implementation: "files_to_modify[0] - Tool detection with preference order"
    tests: "test_requirements.unit[0,1,2]"

  - id: "AC-3.3"
    text: "(P1) Installation validates that mcp_server is importable after install"
    implementation: "files_to_modify[0] - Retain validate_installation() call"
    tests: "test_requirements.unit[4], integration[1]"

  - id: "AC-3.4"
    text: "(P1) Error handling provides clear messages if requirements.txt is missing"
    implementation: "files_to_modify[0] - Pre-install validation of requirements.txt existence"
    tests: "test_requirements.unit[3], integration[2]"

# Implementation Notes
implementation_notes:
  requirements_txt_path: "Path.home() / '.graphiti' / 'requirements.txt'"

  tool_preference_order:
    - "1. uvx (fastest, uv's tool runner)"
    - "2. uv pip (uv's pip implementation)"
    - "3. standard pip (universal fallback)"

  command_examples:
    uvx: "uvx pip install -r ~/.graphiti/requirements.txt"
    uv_pip: "uv pip install -r ~/.graphiti/requirements.txt"
    pip: "pip install -r ~/.graphiti/requirements.txt"

  error_scenarios:
    missing_requirements_txt: "Fail with: 'Requirements file not found at ~/.graphiti/requirements.txt. Run daemon install first.'"
    malformed_requirements_txt: "Fail with: 'Requirements file is malformed or unreadable'"
    installation_failed: "Fail with: 'Package installation failed: {error details}'"
    validation_failed: "Fail with: 'Packages installed but mcp_server not importable'"

  backward_compatibility:
    - "detect_repo_location() method kept for potential dev/test use cases"
    - "No changes to DaemonManager.install() workflow order"
    - "Installation still validates with validate_installation('mcp_server')"

# Dependencies
dependencies:
  - "Story 1 (Generate requirements.txt) MUST be completed first"
  - "Story 2 (Deploy standalone package) MUST be completed first"
  - "Reason: install_package() expects ~/.graphiti/requirements.txt to exist"
  - "Note: Package deployment (Story 2) should run BEFORE install_package() in workflow"

# Migration Strategy
migration_strategy:
  existing_installations: "Running install with new venv_manager will use requirements.txt instead of repo"
  dev_environment: "Developers can still use GRAPHITI_REPO_PATH env var if needed for testing"
  rollback: "Revert venv_manager.py to use detect_repo_location() approach"

# Success Criteria
success_criteria:
  - "install_package() successfully installs from ~/.graphiti/requirements.txt"
  - "Tool preference order works: uvx → uv pip → pip"
  - "validate_installation() confirms mcp_server is importable"
  - "Clear error message if requirements.txt is missing"
  - "Tests pass on Windows and Unix platforms"
  - "No breaking changes to DaemonManager.install() workflow"

# File Modification Details

## venv_manager.py changes

### Current install_package() structure (lines 416-516):
```
def install_package(self) -> Tuple[bool, str]:
    # 1. Check venv exists
    # 2. Detect repository location (detect_repo_location())
    # 3. Validate repo path (mcp_server/ directory)
    # 4. Determine pip tool (uv pip vs pip)
    # 5. Build install command: pip install ./mcp_server
    # 6. Run installation subprocess
    # 7. Validate installation (validate_installation())
    # 8. Return result
```

### New install_package() structure:
```
def install_package(self) -> Tuple[bool, str]:
    # 1. Check venv exists
    # 2. Validate requirements.txt exists at ~/.graphiti/requirements.txt
    # 3. Determine pip tool (prefer uvx, then uv pip, then pip)
    # 4. Build install command: pip install -r ~/.graphiti/requirements.txt
    # 5. Run installation subprocess
    # 6. Validate installation (validate_installation())
    # 7. Return result
```

### Specific code changes:

**Remove (lines ~436-456):**
```python
# Detect repository location
repo_path = self.detect_repo_location()
if repo_path is None:
    error_msg = (
        "Cannot find mcp_server package in repository. "
        "Expected to find mcp_server/pyproject.toml searching upward from venv."
    )
    logger.error(error_msg)
    return False, error_msg

# Validate repo path (security: prevent path traversal)
try:
    repo_path = repo_path.resolve()
    mcp_server_path = repo_path / "mcp_server"
    if not mcp_server_path.exists():
        error_msg = f"mcp_server directory not found at {mcp_server_path}"
        logger.error(error_msg)
        return False, error_msg
except Exception as e:
    error_msg = f"Error validating repository path: {e}"
    logger.error(error_msg)
    return False, error_msg
```

**Add (replacement):**
```python
# Validate requirements.txt exists
requirements_path = Path.home() / ".graphiti" / "requirements.txt"
if not requirements_path.exists():
    error_msg = (
        f"Requirements file not found at {requirements_path}. "
        "Please run the daemon installation process first."
    )
    logger.error(error_msg)
    return False, error_msg

logger.debug(f"Using requirements file: {requirements_path}")
```

**Modify tool detection (lines ~458-466):**

Current:
```python
# Determine which pip to use (prefer uv pip if available in venv)
uv_exe = self.get_uv_executable()
if uv_exe:
    pip_command = [str(uv_exe), "pip", "install"]
    tool_name = "uv pip"
else:
    pip_exe = self.get_pip_executable()
    pip_command = [str(pip_exe), "install"]
    tool_name = "pip"
```

New:
```python
# Determine which tool to use (prefer uvx, then uv pip, then pip)
# Check for uvx in PATH first
uvx_path = shutil.which("uvx")
if uvx_path:
    pip_command = [uvx_path, "pip", "install"]
    tool_name = "uvx"
else:
    # Check for uv in venv
    uv_exe = self.get_uv_executable()
    if uv_exe:
        pip_command = [str(uv_exe), "pip", "install"]
        tool_name = "uv pip"
    else:
        # Fallback to standard pip
        pip_exe = self.get_pip_executable()
        pip_command = [str(pip_exe), "install"]
        tool_name = "pip"
```

**Modify install command (lines ~468-474):**

Current:
```python
# Build install command (non-editable, use relative path ./mcp_server)
install_target = str(mcp_server_path.relative_to(repo_path))
install_command = pip_command + [install_target, "--quiet"]

logger.info(f"Installing mcp_server package using {tool_name}")
logger.debug(f"Install command: {' '.join(install_command)}")
logger.debug(f"Working directory: {repo_path}")
```

New:
```python
# Build install command (install from requirements.txt)
install_command = pip_command + ["-r", str(requirements_path), "--quiet"]

logger.info(f"Installing dependencies from {requirements_path} using {tool_name}")
logger.debug(f"Install command: {' '.join(install_command)}")
```

**Modify subprocess execution (lines ~476-484):**

Current:
```python
result = subprocess.run(
    install_command,
    cwd=str(repo_path),  # Run from repo root
    capture_output=True,
    text=True,
    check=False,
    timeout=300,  # 5 minute timeout for package installation
)
```

New:
```python
result = subprocess.run(
    install_command,
    # No cwd needed - requirements.txt has absolute path
    capture_output=True,
    text=True,
    check=False,
    timeout=300,  # 5 minute timeout for package installation
)
```

**Keep validation unchanged (lines ~486-516):** No changes needed to validation logic.

## test_venv_manager.py changes

### Add fixture for requirements.txt:
```python
@pytest.fixture
def mock_requirements_txt(tmp_path):
    """Create a mock requirements.txt file."""
    req_file = tmp_path / ".graphiti" / "requirements.txt"
    req_file.parent.mkdir(parents=True, exist_ok=True)
    req_file.write_text("mcp>=1.9.4\nopenai>=1.91.0\ngraphiti-core>=0.23.1\n")
    return req_file
```

### Modify test_install_package:
- Mock Path.home() to return tmp_path
- Create requirements.txt fixture
- Update subprocess assertions to expect "pip install -r {requirements_path}"
- Remove repository detection mocks

### Add new tests:
- test_install_package_with_uvx()
- test_install_package_with_uv_pip()
- test_install_package_missing_requirements_txt()
- test_install_package_malformed_requirements_txt()
