# Plan: 4
# Generated by: discovery:4.d
# Timestamp: 2025-12-20T15:45:00Z

story_id: "4"
title: "Reconciliation Application Functions"
created: "2025-12-20T15:45:00Z"
created_by: "discovery:4.d"

# Analysis Summary
analysis:
  summary: "Implement three reconciliation application functions (propagate, retest, supersede) that update validation story status and metadata based on remediation testing outcomes. Trigger container status propagation after each application."
  complexity: "medium"
  estimated_files: 2
  estimated_tokens: 15000
  risk_factors:
    - "Status propagation must handle container hierarchies (validation -> parent story)"
    - "Audit trail metadata must be comprehensive for troubleshooting"
    - "Edge cases: multiple remediations, already-completed validations, partial overlaps"
    - "Integration with existing queue_helpers functions (set_metadata, update-status)"

# Files to Create
files_to_create:
  - path: "resources/commands/sprint/queue_helpers/reconciliation.py"
    purpose: "Implement three reconciliation application functions"
    pattern_source: "resources/commands/sprint/queue_helpers/overlap.py"
    estimated_lines: 400

# Files to Modify
files_to_modify:
  - path: "resources/commands/sprint/queue_helpers/__init__.py"
    changes:
      - "Import reconciliation application functions"
      - "Export apply_propagate_reconciliation, apply_retest_reconciliation, apply_supersede_reconciliation"
    lines_affected: 10

# Module Design
module:
  location: "resources/commands/sprint/queue_helpers/reconciliation.py"
  dependencies:
    - "queue_helpers.core (load_queue, save_queue, set_metadata)"
    - "queue_helpers.overlap (calculate_test_overlap, same_test_parameters, determine_reconciliation_mode)"
    - "queue_helpers.containers (propagate_status_to_parent - may need to create)"
    - "datetime (for audit timestamps)"
    - "pathlib (for file operations)"
    - "typing (type hints)"

# Function Signatures
function_signatures:
  apply_propagate_reconciliation:
    description: "Mark validation as completed by propagating remediation test results (no retest needed)"
    signature: |
      def apply_propagate_reconciliation(
          target_validation_id: str,
          source_remediation_id: str,
          test_results: dict[str, Any],
          sprint_dir: str = ".claude/sprint"
      ) -> dict[str, Any]
    parameters:
      - name: "target_validation_id"
        type: "str"
        description: "Validation story ID to update (e.g., '-1.t')"
      - name: "source_remediation_id"
        type: "str"
        description: "Remediation story ID that provided passing results (e.g., '1.r.t')"
      - name: "test_results"
        type: "dict[str, Any]"
        description: "Test results from remediation (pass_rate, test_count, test_files, etc.)"
      - name: "sprint_dir"
        type: "str"
        description: "Sprint directory path (default: .claude/sprint)"
    returns:
      type: "dict[str, Any]"
      description: "Result object with status, message, updated_stories list"
    behavior:
      - "Load queue from .queue.json"
      - "Update target validation story status to 'completed'"
      - "Set reconciliation metadata with source story, timestamp, audit trail"
      - "Trigger container status propagation to parent validation story"
      - "Save updated queue"
      - "Return result with list of updated story IDs"
    metadata_created:
      reconciliation:
        status: "propagated"
        source_story: "source_remediation_id"
        source_pass_rate: "test_results.pass_rate"
        source_test_count: "test_results.test_count"
        applied_at: "ISO timestamp (datetime.utcnow().isoformat())"
        propagation_note: "Pass propagated from {source_story} ({pass_rate}% pass rate, {passed}/{total} tests)"

  apply_retest_reconciliation:
    description: "Unblock validation with needs_retest flag (test overlap insufficient for propagation)"
    signature: |
      def apply_retest_reconciliation(
          target_validation_id: str,
          source_remediation_id: str,
          test_results: dict[str, Any],
          retest_reason: str = "Test overlap below propagation threshold",
          sprint_dir: str = ".claude/sprint"
      ) -> dict[str, Any]
    parameters:
      - name: "target_validation_id"
        type: "str"
        description: "Validation story ID to update (e.g., '-1.t')"
      - name: "source_remediation_id"
        type: "str"
        description: "Remediation story ID that triggered retest (e.g., '1.r.t')"
      - name: "test_results"
        type: "dict[str, Any]"
        description: "Test results from remediation"
      - name: "retest_reason"
        type: "str"
        description: "Reason why retest is required (default: overlap threshold)"
      - name: "sprint_dir"
        type: "str"
        description: "Sprint directory path (default: .claude/sprint)"
    returns:
      type: "dict[str, Any]"
      description: "Result object with status, message, updated_stories list"
    behavior:
      - "Load queue from .queue.json"
      - "Update target validation story status to 'unassigned' (unblocked, ready for execution)"
      - "Set reconciliation metadata with needs_retest flag and reason"
      - "DO NOT propagate to parent container (validation still needs execution)"
      - "Save updated queue"
      - "Return result with list of updated story IDs"
    metadata_created:
      reconciliation:
        status: "pending_retest"
        source_story: "source_remediation_id"
        needs_retest: true
        retest_reason: "retest_reason parameter"
        applied_at: "ISO timestamp"

  apply_supersede_reconciliation:
    description: "Mark validation as superseded (original tests obsolete, replaced by remediation approach)"
    signature: |
      def apply_supersede_reconciliation(
          target_validation_id: str,
          source_remediation_id: str,
          test_results: dict[str, Any],
          supersession_reason: str,
          sprint_dir: str = ".claude/sprint"
      ) -> dict[str, Any]
    parameters:
      - name: "target_validation_id"
        type: "str"
        description: "Validation story ID to mark as superseded (e.g., '-1.t')"
      - name: "source_remediation_id"
        type: "str"
        description: "Remediation story ID that supersedes (e.g., '1.r.t')"
      - name: "test_results"
        type: "dict[str, Any]"
        description: "Test results from remediation"
      - name: "supersession_reason"
        type: "str"
        description: "Reason why original tests are obsolete (required, user-provided)"
      - name: "sprint_dir"
        type: "str"
        description: "Sprint directory path (default: .claude/sprint)"
    returns:
      type: "dict[str, Any]"
      description: "Result object with status, message, updated_stories list"
    behavior:
      - "Load queue from .queue.json"
      - "Update target validation story status to 'superseded'"
      - "Set reconciliation metadata with superseded_by and reason"
      - "Trigger container status propagation to parent (superseded counts as resolved)"
      - "Save updated queue"
      - "Return result with list of updated story IDs"
    metadata_created:
      reconciliation:
        status: "superseded"
        superseded_by: "source_remediation_id"
        supersession_reason: "supersession_reason parameter"
        applied_at: "ISO timestamp"

# Container Status Propagation
container_propagation:
  description: "After reconciliation application, update parent container status based on child states"
  function_name: "propagate_status_to_parent"
  location: "resources/commands/sprint/queue_helpers/containers.py (may need to create or extend)"
  signature: |
    def propagate_status_to_parent(
        child_story_id: str,
        queue: dict[str, Any],
        treat_superseded_as: str = "completed"
    ) -> dict[str, Any]
  behavior:
    - "Get child story and parent ID from queue"
    - "If no parent, return queue unchanged"
    - "Get all children of parent container"
    - "Calculate parent status based on children states:"
    - "  - All children completed/superseded -> parent 'completed'"
    - "  - Any child blocked -> parent 'blocked'"
    - "  - Any child in_progress -> parent 'in_progress'"
    - "  - Otherwise -> parent status unchanged"
    - "Update parent story status if changed"
    - "Recursively propagate to grandparent if parent changed"
    - "Return updated queue"
  status_mapping:
    completed: "resolved"
    superseded: "resolved (if treat_superseded_as='completed')"
    blocked: "blocked"
    in_progress: "in_progress"
    unassigned: "pending"

# Queue Interaction
queue_operations:
  read_queue:
    function: "load_queue(sprint_dir)"
    module: "queue_helpers.core"
    returns: "dict[str, Any] - parsed .queue.json"

  write_queue:
    function: "save_queue(queue, sprint_dir)"
    module: "queue_helpers.core"
    returns: "None - writes to .queue.json"

  update_status:
    method: "Direct dictionary update"
    pattern: "queue['stories'][story_id]['status'] = new_status"
    note: "After update, call save_queue() to persist"

  set_metadata_field:
    function: "set_metadata(queue, story_id, key, value)"
    module: "queue_helpers.core"
    validation: "Automatically validates reconciliation metadata schema"
    note: "Returns new queue dict (immutable pattern)"

  get_story:
    method: "Dictionary lookup"
    pattern: "story = queue['stories'][story_id]"
    error_handling: "Check if story_id in queue['stories'] before access"

# Integration Points
integration:
  - file: "resources/commands/sprint/queue_helpers/overlap.py"
    type: "dependency"
    description: "Use calculate_test_overlap() and determine_reconciliation_mode() to determine which application function to call"

  - file: "resources/commands/sprint/queue_helpers/test_reconciliation.py"
    type: "dependency"
    description: "Reconciliation metadata validated against schema (validate_reconciliation())"

  - file: "resources/commands/sprint/queue_helpers/core.py"
    type: "import"
    description: "Import load_queue, save_queue, set_metadata functions"

  - file: ".claude/sprint/.queue.json"
    type: "data"
    description: "Read/write queue file to update story status and metadata"

  - file: "~/.claude/commands/sprint/NEXT.md (future)"
    type: "consumer"
    description: "Testing phase completion will call reconciliation functions (Story 6)"

# Patterns to Follow
patterns:
  - source: "resources/commands/sprint/queue_helpers/overlap.py"
    pattern: "Module structure with typed functions, comprehensive docstrings, edge case handling"

  - source: "resources/commands/sprint/queue_helpers/core.py"
    pattern: "Immutable queue updates (deepcopy, return new dict) for safety"

  - source: "Python best practices"
    pattern: "Type hints for all parameters and return values"

  - source: "resources/commands/sprint/queue_helpers/overlap.py"
    pattern: "Defensive error handling (check story exists before update)"

# Error Handling
error_cases:
  - case: "Target validation story not found in queue"
    handling: "Raise ValueError with clear message"

  - case: "Target validation already completed (not blocked)"
    handling: "Log warning, skip reconciliation, return success (idempotent)"

  - case: "Source remediation story not found"
    handling: "Raise ValueError (invalid source story ID)"

  - case: "Queue file missing or corrupted"
    handling: "Propagate exception from load_queue() (no special handling)"

  - case: "Reconciliation metadata validation fails"
    handling: "Raise ValueError from set_metadata() (schema validation)"

  - case: "Multiple remediations target same validation"
    handling: "First reconciliation wins, subsequent ones skip (check existing metadata)"

# Test Requirements
test_requirements:
  unit:
    - "Test apply_propagate_reconciliation() updates status to 'completed'"
    - "Test apply_propagate_reconciliation() sets correct reconciliation metadata"
    - "Test apply_propagate_reconciliation() creates audit trail with timestamp"
    - "Test apply_retest_reconciliation() updates status to 'unassigned'"
    - "Test apply_retest_reconciliation() sets needs_retest flag"
    - "Test apply_retest_reconciliation() includes retest_reason in metadata"
    - "Test apply_supersede_reconciliation() updates status to 'superseded'"
    - "Test apply_supersede_reconciliation() includes supersession_reason"
    - "Test propagate_status_to_parent() updates parent when all children completed"
    - "Test propagate_status_to_parent() keeps parent blocked if any child blocked"
    - "Test propagate_status_to_parent() handles superseded as completed"
    - "Test error handling for missing target validation"
    - "Test error handling for missing source remediation"
    - "Test idempotency - applying reconciliation twice doesn't fail"
    - "Test metadata schema validation (invalid reconciliation metadata rejected)"

  integration:
    - "Test full propagate flow: remediation passes -> validation completed -> parent updated"
    - "Test full retest flow: partial overlap -> validation unblocked -> parent unchanged"
    - "Test full supersede flow: supersession -> validation superseded -> parent completed"
    - "Test container status propagation up hierarchy (child -> parent -> grandparent)"
    - "Test reconciliation with real .queue.json (read, update, save, verify)"
    - "Test multiple remediations for same validation (first wins)"
    - "Test already-completed validation (skip reconciliation gracefully)"

  security:
    - "Test malicious story IDs (path traversal, SQL injection patterns)"
    - "Test extremely large test_results dictionaries (DoS prevention)"
    - "Test metadata injection attempts (script tags, executable code)"

# Acceptance Criteria Mapping
acceptance_criteria:
  - id: "AC-4.1"
    text: "(P0) apply_propagate_reconciliation() marks validation as completed with source metadata"
    implementation: "files_to_create[0] - reconciliation.py implements apply_propagate_reconciliation()"
    tests: "test_requirements.unit[0-2], test_requirements.integration[0]"

  - id: "AC-4.2"
    text: "(P0) apply_retest_reconciliation() unblocks validation with needs_retest flag"
    implementation: "files_to_create[0] - reconciliation.py implements apply_retest_reconciliation()"
    tests: "test_requirements.unit[3-5], test_requirements.integration[1]"

  - id: "AC-4.3"
    text: "(P0) apply_supersede_reconciliation() marks validation as superseded"
    implementation: "files_to_create[0] - reconciliation.py implements apply_supersede_reconciliation()"
    tests: "test_requirements.unit[6-7], test_requirements.integration[2]"

  - id: "AC-4.4"
    text: "All functions update validation story metadata with audit trail"
    implementation: "All three functions use set_metadata() to record reconciliation details"
    tests: "test_requirements.unit[1,5,7], test_requirements.integration[0-2]"

  - id: "AC-4.5"
    text: "Container status propagation triggered after each application"
    implementation: "propagate_status_to_parent() called in propagate and supersede modes"
    tests: "test_requirements.unit[8-10], test_requirements.integration[3]"

  - id: "AC-4.6"
    text: "Unit tests for each mode"
    implementation: "Test file creation in testing phase"
    tests: "test_requirements.unit[all]"

# Implementation Notes
implementation_notes:
  - note: "Use queue_helpers.core.set_metadata() for metadata updates (automatic validation)"
    rationale: "Centralized metadata validation prevents schema errors"

  - note: "All functions return result dict with status, message, updated_stories list"
    rationale: "Caller needs to know what changed for logging/reporting"

  - note: "Propagation and supersession trigger container status updates, retest does not"
    rationale: "Retest mode leaves validation in unassigned state (still needs execution)"

  - note: "Treat superseded as completed for container status calculation"
    rationale: "Superseded validations are resolved (no action needed)"

  - note: "Check for existing reconciliation metadata before applying (idempotency)"
    rationale: "Multiple remediations for same validation should not conflict"

  - note: "Use datetime.utcnow().isoformat() for timestamps (ISO 8601 format)"
    rationale: "Consistent timestamp format for audit trail"

  - note: "Container propagation may need to be implemented or extended from existing code"
    rationale: "Check if propagate_status_to_parent() already exists in codebase"

# Return Value Schema
return_value_schema:
  success:
    status: "success"
    mode: "propagate | retest | supersede"
    target: "target_validation_id"
    source: "source_remediation_id"
    message: "Human-readable success message"
    updated_stories:
      - "target_validation_id"
      - "parent_container_id (if propagated)"

  error:
    status: "error"
    error: "Error message"
    target: "target_validation_id (if available)"

  skipped:
    status: "skipped"
    reason: "Why reconciliation was skipped (e.g., already completed)"
    target: "target_validation_id"

# Dependencies
dependencies:
  - story_id: "3"
    type: "requires"
    reason: "Uses overlap calculation algorithm to determine reconciliation mode"

  - story_id: "1"
    type: "requires"
    reason: "Uses test_reconciliation and reconciliation metadata schemas"

# Blocks
blocks:
  - story_id: "5"
    reason: "Container Status Propagation depends on reconciliation application"

  - story_id: "6"
    reason: "Remediation Testing Trigger will call these functions"

  - story_id: "7"
    reason: "queue_helpers.py CLI commands will expose these functions"

# Future Enhancements (Out of Scope for Story 4)
future_enhancements:
  - "Automatic reconciliation trigger from NEXT command (Story 6)"
  - "CLI commands for manual reconciliation (queue_helpers.py - Story 7)"
  - "Reconciliation status reporting and analytics"
  - "Configurable overlap thresholds per-project"
  - "Partial propagation (some tests pass, others still need retest)"
