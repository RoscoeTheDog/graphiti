# Plan: 2
# Generated by: discovery:2.d
# Timestamp: 2025-12-14T22:30:00Z

story_id: "2"
title: "Package Installation to Dedicated Venv"
created: "2025-12-14T22:30:00Z"
created_by: "discovery:2.d"

# Analysis Summary
analysis:
  summary: "Install mcp_server package (non-editable) into ~/.graphiti/.venv/ during daemon install using uv pip (preferred) or pip (fallback), with dynamic repo detection and installation validation"
  complexity: "medium"
  estimated_files: 2
  estimated_tokens: 6000
  risk_factors:
    - "Repo location must be discovered dynamically (no hardcoded paths)"
    - "Non-editable install means package is copied, not linked (affects updates)"
    - "uv pip vs standard pip have different command syntax"
    - "Installation validation must confirm package is importable"
    - "Must handle cases where repo is moved after installation"

# Files to Create
files_to_create: []

# Files to Modify
files_to_modify:
  - path: "mcp_server/daemon/venv_manager.py"
    changes:
      - "Add install_package() method to install mcp_server package into venv"
      - "Add detect_repo_location() method to dynamically find mcp_server directory"
      - "Add validate_installation() method to verify package was installed successfully"
      - "Add get_uv_executable() helper method to get uv path in venv (if uv was used)"
      - "Use subprocess to run: uv pip install ./mcp_server (or pip install ./mcp_server)"
      - "Support both uv pip (preferred) and standard pip (fallback)"
    lines_affected: 80
    details:
      - "install_package() will detect repo location, construct install command, execute, and validate"
      - "detect_repo_location() will search upward from venv path to find directory containing mcp_server/pyproject.toml"
      - "validate_installation() will attempt to import mcp_server package to confirm installation"
      - "Use non-editable install (no -e flag) so package is copied, not linked"

  - path: "mcp_server/daemon/manager.py"
    changes:
      - "Add package installation step to install() method (after venv creation, before service installation)"
      - "Call venv_manager.install_package() after venv creation succeeds"
      - "Display package installation status (success/failure)"
      - "Handle installation failures gracefully"
    lines_affected: 25
    details:
      - "Insert between Step 2 (venv creation) and Step 3 (config directory creation)"
      - "Print status: 'Installing mcp_server package...'"
      - "On success: '[OK] Package installed successfully'"
      - "On failure: '[FAILED] Package installation failed: <error>'"

# Integration Points
integration:
  - file: "mcp_server/daemon/venv_manager.py"
    type: "method"
    description: "Add install_package() as new public method of VenvManager class"

  - file: "mcp_server/daemon/manager.py"
    type: "method_call"
    description: "Call venv_manager.install_package() in install() method after venv creation"

  - file: "mcp_server/daemon/venv_manager.py"
    type: "subprocess"
    description: "Execute 'uv pip install' or 'pip install' command via subprocess"

# Patterns to Follow
patterns:
  - source: "mcp_server/daemon/venv_manager.py"
    pattern: "Subprocess execution with capture_output=True and returncode checking (see create_venv())"

  - source: "mcp_server/daemon/venv_manager.py"
    pattern: "Tool detection pattern (check_uv_available()) for uv availability"

  - source: "mcp_server/daemon/venv_manager.py"
    pattern: "Path handling with pathlib.Path for cross-platform compatibility"

  - source: "mcp_server/daemon/manager.py"
    pattern: "Install step pattern with [OK]/[FAILED] status messages and error handling"

  - source: "mcp_server/daemon/venv_manager.py"
    pattern: "Exception handling with custom exception classes (VenvCreationError)"

# Test Requirements
test_requirements:
  unit:
    - "VenvManager.detect_repo_location() finds mcp_server directory from venv path"
    - "VenvManager.detect_repo_location() handles case where repo is moved"
    - "VenvManager.install_package() uses uv pip when uv available in venv"
    - "VenvManager.install_package() falls back to pip when uv not available"
    - "VenvManager.install_package() uses non-editable install (no -e flag)"
    - "VenvManager.install_package() constructs correct install command with dynamic path"
    - "VenvManager.validate_installation() returns True when package is importable"
    - "VenvManager.validate_installation() returns False when package is not installed"
    - "VenvManager.install_package() raises error on installation failure"

  integration:
    - "daemon install installs mcp_server package into venv after venv creation"
    - "daemon install uses uv pip when uv is available"
    - "daemon install falls back to standard pip when uv not available"
    - "daemon install validates package installation succeeded"
    - "daemon install fails gracefully if package installation fails"
    - "installed package is importable from venv Python interpreter"
    - "graphiti-mcp CLI script is available after installation"
    - "non-editable install means package changes in repo don't affect venv"

  security:
    - "Repo path is validated before installation (prevent path traversal)"
    - "Subprocess commands are properly escaped (no shell injection)"
    - "Package installation does not require elevated privileges"

# Acceptance Criteria Mapping
acceptance_criteria:
  - id: "AC-2.1"
    text: "(P0) daemon install runs 'uv pip install ./mcp_server' (or pip fallback) into ~/.graphiti/.venv/"
    implementation: "files_to_modify[0] (venv_manager.py: install_package()) + files_to_modify[1] (manager.py: install())"
    tests: "test_requirements.integration[0,1,2]"

  - id: "AC-2.2"
    text: "(P0) Installation is non-editable (stable, not tied to repo location)"
    implementation: "files_to_modify[0] (venv_manager.py: install_package() without -e flag)"
    tests: "test_requirements.unit[4] + test_requirements.integration[7]"

  - id: "AC-2.3"
    text: "(P1) Detects repo location dynamically at install time (no hardcoded paths)"
    implementation: "files_to_modify[0] (venv_manager.py: detect_repo_location())"
    tests: "test_requirements.unit[0,1,5]"

  - id: "AC-2.4"
    text: "(P1) Validates successful installation before proceeding"
    implementation: "files_to_modify[0] (venv_manager.py: validate_installation())"
    tests: "test_requirements.unit[6,7] + test_requirements.integration[3,5]"

# Implementation Notes
implementation_notes:
  - "Non-editable install: Use 'pip install ./mcp_server' NOT 'pip install -e ./mcp_server'"
  - "Dynamic repo detection: Search upward from ~/.graphiti/.venv/ for directory containing mcp_server/pyproject.toml"
  - "Validation: After install, try to import mcp_server package using venv's Python interpreter"
  - "uv pip vs pip: Both support same syntax for local package install (./mcp_server)"
  - "Install command: [uv_or_pip_exe] install ./mcp_server (relative path from repo root)"
  - "Consider adding --quiet flag to reduce installation output noise"
  - "Future: Story 3 will use installed package to generate CLI wrapper scripts"

# Dependencies
dependencies:
  internal:
    - "Requires pathlib (standard library)"
    - "Requires subprocess (standard library)"
    - "Requires sys (standard library)"
    - "Requires logging (standard library)"
  external:
    - "Requires venv from Story 1 to exist at ~/.graphiti/.venv/"
    - "Requires mcp_server/pyproject.toml to be present in repo"
    - "Optional: uv (falls back to pip if not available)"
  blocking_stories:
    - "Story 1: Dedicated Venv Creation (must complete first)"

# Performance Considerations
performance:
  - "Package installation is one-time operation during install (~5-30 seconds depending on dependencies)"
  - "Repo detection should be fast (<100ms) using Path.exists() checks"
  - "Installation validation should be fast (~200ms) using import check"
  - "Avoid re-installing package on subsequent 'daemon install' runs (check if already installed)"

# Error Handling
error_scenarios:
  - scenario: "Repo location cannot be detected (mcp_server/pyproject.toml not found)"
    handling: "Display clear error: 'Cannot find mcp_server package in repo', suggest running from correct directory"

  - scenario: "Package installation fails (pip/uv error)"
    handling: "Display subprocess error output, suggest checking internet connection for dependency downloads"

  - scenario: "Package installs but validation fails (import error)"
    handling: "Display import error, suggest checking package dependencies, offer to retry installation"

  - scenario: "Venv does not exist (Story 1 not completed)"
    handling: "Raise VenvCreationError with message 'Venv must be created before installing packages'"

  - scenario: "Insufficient disk space for package installation"
    handling: "Subprocess will fail, catch error, display disk space message"

# Design Decisions
design_decisions:
  - decision: "Non-editable install (copy package, don't link)"
    rationale: "Makes installation stable and independent of repo location. User can move/delete repo after install."
    tradeoffs: "Package updates require re-running 'daemon install'. Editable mode would auto-update but ties install to repo."

  - decision: "Dynamic repo detection instead of hardcoded paths"
    rationale: "Installation works regardless of where user clones the repo (~/dev/graphiti vs /opt/graphiti vs C:/Projects/graphiti)"
    tradeoffs: "Requires upward search algorithm, slightly more complex. But enables portable installation."

  - decision: "Validate installation by attempting import"
    rationale: "Ensures package is truly usable, not just copied. Catches missing dependencies early."
    tradeoffs: "Adds ~200ms to installation time. But prevents silent failures."

  - decision: "Use local package install (./mcp_server) not editable mode (-e)"
    rationale: "Matches acceptance criteria 'not tied to repo location'. Standard install copies files."
    tradeoffs: "Requires re-install to pick up package changes. But provides stability."
