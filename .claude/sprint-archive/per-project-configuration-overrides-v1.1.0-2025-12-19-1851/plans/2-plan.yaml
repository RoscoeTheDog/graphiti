# Plan: 2
# Generated by: discovery:2.d
# Timestamp: 2025-12-18T17:56:00Z

story_id: "2"
title: "Implement get_effective_config() Method"
created: "2025-12-18T17:56:00Z"
created_by: "discovery:2.d"

# Analysis Summary
analysis:
  summary: "Add get_effective_config() instance method to GraphitiConfig that looks up project_path in project_overrides, performs deep merge if found, and returns merged config. Update get_config() function to accept optional project_path parameter. Implement validation to warn about non-overridable sections in overrides."
  complexity: "medium"
  estimated_files: 2
  estimated_tokens: 5000
  risk_factors:
    - "Deep merge must correctly merge Pydantic models (need to convert to dict, merge, reconstruct)"
    - "Non-overridable section detection must be comprehensive (database, daemon, resilience, mcp_server, logging)"
    - "get_config() signature change must maintain backward compatibility"
    - "Return value must be a valid GraphitiConfig instance (not dict)"

# Dependencies
dependencies:
  - story_id: "1"
    status: "completed"
    provided: ["ProjectOverride schema", "normalize_project_path()", "deep_merge()"]

# Files to Modify
files_to_modify:
  - path: "mcp_server/unified_config.py"
    changes:
      - "Add get_effective_config(project_path) method to GraphitiConfig class (~line 1050)"
      - "Update get_config() function to accept optional project_path parameter (~line 1206)"
      - "Add _validate_override() helper method to check for non-overridable sections (~line 1040)"
    lines_affected: 80

  - path: "tests/test_project_overrides.py"
    changes:
      - "Add TestGetEffectiveConfig test class"
      - "Add test_get_effective_config_no_override()"
      - "Add test_get_effective_config_with_override()"
      - "Add test_get_effective_config_merge_nested()"
      - "Add test_get_config_with_project_path()"
      - "Add test_validate_override_warns_non_overridable()"
    lines_affected: 150

# Key Implementation Details
implementation:
  get_effective_config:
    signature: "def get_effective_config(self, project_path: str) -> GraphitiConfig"
    algorithm:
      - "Normalize project_path using normalize_project_path()"
      - "Look up normalized path in self.project_overrides dict"
      - "If not found: return self (global config unchanged)"
      - "If found: perform deep merge and return merged config"
    merge_approach:
      - "Convert self to dict using self.model_dump()"
      - "Convert override to dict using override.model_dump(exclude_none=True)"
      - "Call deep_merge(base_dict, override_dict)"
      - "Reconstruct GraphitiConfig from merged dict"
      - "Return new GraphitiConfig instance"

  validate_override:
    signature: "def _validate_override(self, override_dict: Dict[str, Any], project_path: str) -> None"
    purpose: "Check for non-overridable sections and log warnings"
    non_overridable_sections:
      - "database"
      - "daemon"
      - "resilience"
      - "mcp_server"
      - "logging"
      - "version"
      - "project"
      - "search"
      - "performance"
    behavior:
      - "For each non-overridable section in override_dict: log warning"
      - "Warning format: 'Project override for {path} contains non-overridable section {section}, ignoring'"
      - "Do not raise exception, just warn and continue"

  get_config_update:
    signature: "def get_config(reload: bool = False, force_reload: bool = False, project_path: str | None = None) -> GraphitiConfig"
    changes:
      - "Add project_path parameter (default None)"
      - "After loading/reloading config: if project_path is not None, call config.get_effective_config(project_path)"
      - "Return effective config instead of base config"
    backward_compatibility:
      - "Existing calls without project_path continue to work (return global config)"
      - "No breaking changes to API"

# Integration Points
integration:
  - file: "mcp_server/unified_config.py"
    type: "method"
    description: "get_effective_config() uses normalize_project_path() and deep_merge() from Story 1"

  - file: "mcp_server/unified_config.py"
    type: "import"
    description: "Import logging for warning messages"

  - file: "mcp_server/graphiti_mcp_server.py"
    type: "future"
    description: "Future Story 3 will update MCP tools to pass project_path to get_config()"

# Patterns to Follow
patterns:
  - source: "mcp_server/unified_config.py (existing methods)"
    pattern: "Instance methods on GraphitiConfig use self, return GraphitiConfig instances"

  - source: "mcp_server/unified_config.py (get_config function)"
    pattern: "Module-level get_config() uses global _config_instance singleton pattern"

  - source: "tests/test_project_overrides.py (existing tests)"
    pattern: "Use pytest fixtures for config setup, assert on merged values, test edge cases"

# Test Requirements
test_requirements:
  unit:
    - "test_get_effective_config_no_override: project_path not in project_overrides → returns self unchanged"
    - "test_get_effective_config_with_override: project_path in overrides → returns merged config"
    - "test_get_effective_config_merge_llm: override.llm.provider='anthropic' → merged.llm.provider='anthropic', other fields inherited"
    - "test_get_effective_config_merge_nested: override.session_tracking.enabled=False → merged.session_tracking.enabled=False, other session_tracking fields inherited"
    - "test_get_effective_config_none_inherits: override.llm=None → merged.llm inherits from global"
    - "test_get_effective_config_normalizes_path: Pass C:\\Users\\Admin\\project → normalizes to /c/Users/Admin/project for lookup"
    - "test_get_config_with_project_path: get_config(project_path='/path') → returns effective config"
    - "test_get_config_without_project_path: get_config() → returns global config (backward compatibility)"
    - "test_validate_override_warns_database: override contains database → logs warning"
    - "test_validate_override_warns_daemon: override contains daemon → logs warning"
    - "test_validate_override_warns_multiple: override contains database+daemon → logs 2 warnings"

  integration:
    - "test_get_effective_config_end_to_end: Create config with override, call get_effective_config(), verify merged values in returned instance"
    - "test_get_config_reload_with_project_path: Force reload with project_path → reloads config and applies override"

  edge_cases:
    - "test_get_effective_config_empty_override: Override exists but all fields None → returns global config"
    - "test_get_effective_config_invalid_path: Malformed path → normalize_project_path() handles gracefully"

# Acceptance Criteria Mapping
acceptance_criteria:
  - id: "AC-1 (P0)"
    text: "get_effective_config(project_path) method added to GraphitiConfig"
    implementation: "files_to_modify[0] - Add instance method to GraphitiConfig class"
    tests: "test_requirements.unit[0-5], test_requirements.integration[0]"

  - id: "AC-2 (P0)"
    text: "Method looks up normalized path in project_overrides dict"
    implementation: "implementation.get_effective_config.algorithm[0-1] - Use normalize_project_path() for lookup"
    tests: "test_requirements.unit[5]"

  - id: "AC-3 (P0)"
    text: "If found, deep merges override with global config"
    implementation: "implementation.get_effective_config.merge_approach - Use deep_merge() for merging"
    tests: "test_requirements.unit[1-4], test_requirements.integration[0]"

  - id: "AC-4 (P0)"
    text: "If not found, returns global config unchanged"
    implementation: "implementation.get_effective_config.algorithm[2] - Return self if no override"
    tests: "test_requirements.unit[0]"

  - id: "AC-5 (P1)"
    text: "Updated get_config() function accepts optional project_path parameter"
    implementation: "implementation.get_config_update - Add project_path param, call get_effective_config() if provided"
    tests: "test_requirements.unit[6-7], test_requirements.integration[1]"

  - id: "AC-6 (P1)"
    text: "Non-overridable sections (database, daemon) ignored in overrides with warning"
    implementation: "implementation.validate_override - Check override dict for non-overridable sections, log warnings"
    tests: "test_requirements.unit[8-10]"

# Implementation Notes
implementation_notes:
  - "get_effective_config() must return a NEW GraphitiConfig instance (not modify self in-place)"
  - "Use model_dump() to convert Pydantic models to dict for merging, then reconstruct with GraphitiConfig(**merged_dict)"
  - "Use exclude_none=True when dumping override to avoid replacing values with None (relies on deep_merge None semantics)"
  - "Call _validate_override() BEFORE deep_merge to log warnings about non-overridable sections"
  - "Non-overridable sections list: database, daemon, resilience, mcp_server, logging, version, project, search, performance"
  - "Overridable sections (from ProjectOverride): llm, embedder, extraction, session_tracking"
  - "get_config() signature change is backward compatible (project_path defaults to None)"
  - "Future Story 3 will update MCP tools (add_memory, search_memory_nodes) to extract project_path and call get_config(project_path=path)"

# Edge Cases to Handle
edge_cases:
  - case: "Empty override (all fields None)"
    handling: "deep_merge with all None values → inherits everything from global config"

  - case: "Partial override (only llm.provider specified)"
    handling: "deep_merge merges llm.provider, inherits all other llm fields from global"

  - case: "Override contains non-overridable section"
    handling: "_validate_override() logs warning, deep_merge includes section (but it won't be used in practice since ProjectOverride schema forbids it)"

  - case: "project_path normalization fails"
    handling: "normalize_project_path() handles errors (Path.resolve fallback), returns normalized string"

  - case: "Multiple calls to get_effective_config()"
    handling: "Each call returns a new instance (idempotent, no side effects)"

# Success Criteria
success_criteria:
  - "All P0 acceptance criteria tests pass"
  - "All P1 acceptance criteria tests pass"
  - "Code passes type checking (mypy)"
  - "Code passes linting (ruff)"
  - "Test coverage >80% for new code"
  - "No breaking changes to existing get_config() API"
  - "Documentation updated in docstrings"
