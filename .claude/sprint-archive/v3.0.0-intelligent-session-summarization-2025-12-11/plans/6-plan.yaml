# Discovery Plan: Story 6 - Bash Command Analysis
# Generated: 2025-12-11
# Phase: discovery (6.d)

story:
  id: "6"
  title: "Bash Command Analysis"
  dependency: "Story 4 (Tool Classification Heuristics)"

# =============================================================================
# DISCOVERY FINDINGS
# =============================================================================

codebase_analysis:
  existing_files:
    - path: "graphiti_core/session_tracking/tool_classifier.py"
      purpose: "Tool classification with heuristics and LLM fallback - Story 4 & 5"
      key_interfaces:
        - "ToolClassifier.classify(tool_name: str, parameters: dict | None) -> ToolClassification"
        - "ToolClassifier.classify_batch(tool_calls: list[tuple]) -> list[ToolClassification]"
        - "ToolClassifier._classify_with_llm(tool_calls) -> list[ToolClassification]"
        - "ToolIntent: Enum with CREATE, MODIFY, DELETE, READ, SEARCH, EXECUTE, CONFIGURE, COMMUNICATE, VALIDATE, TRANSFORM"
        - "ToolDomain: Enum with FILESYSTEM, CODE, DATABASE, NETWORK, PROCESS, VERSION_CONTROL, PACKAGE, DOCUMENTATION, TESTING, MEMORY, UNKNOWN"
        - "ToolClassification: BaseModel with intent, domain, confidence, activity_signals, tool_name, method"
      patterns_to_reuse:
        - "ToolIntent and ToolDomain enums for classification"
        - "Activity signal mapping pattern (intent -> activity dimensions)"
        - "LLM fallback pattern with structured Pydantic response"
        - "method field: 'heuristic', 'llm', 'cached'"

    - path: "graphiti_core/session_tracking/activity_vector.py"
      purpose: "ActivityVector model (8 dimensions) - Story 2"
      key_interfaces:
        - "ActivityVector.from_signals(signals: dict[str, float]) -> ActivityVector"
        - "Dimensions: building, fixing, configuring, exploring, refactoring, reviewing, testing, documenting"
      patterns_to_reuse:
        - "ActivityVector.from_signals() for creating activity vectors from classification"

    - path: "graphiti_core/session_tracking/activity_detector.py"
      purpose: "Detect activity from messages - Story 3"
      key_interfaces:
        - "ActivityDetector.detect(messages) -> ActivityVector"
      integration_point: "BashAnalyzer will be used by Unified Tool Classifier (Story 7)"

    - path: "graphiti_core/llm_client/client.py"
      purpose: "LLM client with caching and structured responses"
      key_interfaces:
        - "LLMClient.generate_response(messages, response_model, ...) -> dict"
      patterns_to_reuse:
        - "Pydantic response_model for structured LLM output"

  patterns_found:
    - pattern: "Heuristic patterns with confidence scores"
      location: "tool_classifier.py:INTENT_PATTERNS, DOMAIN_PATTERNS"
      reuse: "Similar pattern for bash command heuristics"

    - pattern: "Activity signal computation from intent+domain"
      location: "tool_classifier.py:_compute_activity_signals()"
      reuse: "Same approach for BashCommandClassification"

    - pattern: "LLM fallback for low-confidence classifications"
      location: "tool_classifier.py:classify_batch()"
      reuse: "BashAnalyzer.classify() will use same LLM fallback pattern"

# =============================================================================
# REQUIREMENTS ANALYSIS
# =============================================================================

acceptance_criteria:
  P0_critical:
    - id: "AC-1"
      description: "BashCommandClassification model with base_command, subcommand, flags, targets"
      implementation_notes: |
        BashCommandClassification(BaseModel):
          raw_command: str          # Original command string
          base_command: str         # "pytest", "git", "npm"
          subcommand: str | None    # "install", "commit", None
          flags: list[str]          # ["-v", "--cov=src"]
          targets: list[str]        # ["tests/"]
          intent: ToolIntent        # From existing enum
          domain: ToolDomain        # From existing enum
          confidence: float         # 0.0-1.0
          reasoning: str            # Classification explanation
          activity_signals: dict[str, float]  # Activity vector contributions
          method: Literal["heuristic", "llm", "cached"]

    - id: "AC-2"
      description: "BashAnalyzer.classify() parses and classifies bash commands"
      implementation_notes: |
        BashAnalyzer class with:
        - classify(command: str) -> BashCommandClassification
        - classify_batch(commands: list[str]) -> list[BashCommandClassification]
        - _parse_command(command) -> tuple[base_command, subcommand, flags, targets]
        - _classify_heuristic(parsed) -> BashCommandClassification | None
        - _classify_with_llm(commands) -> list[BashCommandClassification]

    - id: "AC-3"
      description: "Heuristic matching for common commands (git, npm, pytest, docker, pip, cargo)"
      implementation_notes: |
        COMMAND_HEURISTICS: dict[str, dict[str, tuple[ToolIntent, ToolDomain, float]]]

        git:
          default: (MODIFY, VERSION_CONTROL, 0.9)
          subcommands:
            add: (CREATE, VERSION_CONTROL, 0.95)
            commit: (CREATE, VERSION_CONTROL, 0.95)
            push: (CREATE, VERSION_CONTROL, 0.95)
            pull: (READ, VERSION_CONTROL, 0.95)
            clone: (READ, VERSION_CONTROL, 0.95)
            diff: (READ, VERSION_CONTROL, 0.95)
            status: (READ, VERSION_CONTROL, 0.95)
            checkout: (MODIFY, VERSION_CONTROL, 0.9)
            branch: (MODIFY, VERSION_CONTROL, 0.9)
            merge: (MODIFY, VERSION_CONTROL, 0.9)
            rebase: (MODIFY, VERSION_CONTROL, 0.9)

        npm/yarn/pnpm:
          default: (EXECUTE, PACKAGE, 0.8)
          subcommands:
            install: (CONFIGURE, PACKAGE, 0.95)
            add: (CONFIGURE, PACKAGE, 0.95)
            remove: (DELETE, PACKAGE, 0.95)
            run: (EXECUTE, PROCESS, 0.9)
            test: (VALIDATE, TESTING, 0.95)
            build: (CREATE, PROCESS, 0.9)
            start: (EXECUTE, PROCESS, 0.9)

        pytest/jest/mocha:
          default: (VALIDATE, TESTING, 0.95)
          subcommands: null  # No subcommands

        docker:
          default: (EXECUTE, PROCESS, 0.8)
          subcommands:
            run: (EXECUTE, PROCESS, 0.95)
            build: (CREATE, PROCESS, 0.95)
            push: (CREATE, NETWORK, 0.9)
            pull: (READ, NETWORK, 0.9)
            exec: (EXECUTE, PROCESS, 0.95)
            ps: (READ, PROCESS, 0.9)
            logs: (READ, PROCESS, 0.9)
            stop: (EXECUTE, PROCESS, 0.9)
            compose: (EXECUTE, PROCESS, 0.85)

        pip/uv:
          default: (EXECUTE, PACKAGE, 0.8)
          subcommands:
            install: (CONFIGURE, PACKAGE, 0.95)
            uninstall: (DELETE, PACKAGE, 0.95)
            freeze: (READ, PACKAGE, 0.9)
            list: (READ, PACKAGE, 0.9)

        cargo:
          default: (EXECUTE, PACKAGE, 0.8)
          subcommands:
            build: (CREATE, CODE, 0.95)
            run: (EXECUTE, PROCESS, 0.9)
            test: (VALIDATE, TESTING, 0.95)
            add: (CONFIGURE, PACKAGE, 0.95)
            install: (CONFIGURE, PACKAGE, 0.95)

        make:
          default: (EXECUTE, PROCESS, 0.85)
          subcommands:
            test: (VALIDATE, TESTING, 0.9)
            build: (CREATE, PROCESS, 0.9)
            clean: (DELETE, FILESYSTEM, 0.9)
            install: (CONFIGURE, PROCESS, 0.9)

  P1_important:
    - id: "AC-4"
      description: "LLM fallback for unknown commands"
      implementation_notes: |
        When heuristic confidence < 0.7 or command not in COMMAND_HEURISTICS:
        - Use LLM to classify the command
        - LLM prompt includes: base_command, subcommand, flags, targets context
        - Return structured BashCommandClassification with method="llm"

        LLM Prompt:
        ```
        Analyze this bash command and classify its intent.

        Command: {command}
        Parsed structure:
        - Base command: {base_command}
        - Subcommand: {subcommand}
        - Flags: {flags}
        - Targets: {targets}

        Determine:
        1. Intent: create, modify, delete, read, search, execute, configure, validate, transform
        2. Domain: filesystem, code, database, network, process, version_control, package, testing, memory
        3. Activity signals (0.0-1.0): building, fixing, configuring, exploring, refactoring, reviewing, testing, documenting
        4. Reasoning: Brief explanation of classification
        ```

    - id: "AC-5"
      description: "Unit tests for command parsing and classification"
      implementation_notes: |
        Test cases:
        - Parse simple command: "pytest tests/"
        - Parse command with flags: "pytest -v --cov=src tests/"
        - Parse command with subcommand: "git commit -m 'message'"
        - Parse complex command: "docker run -d -p 8080:80 nginx"
        - Parse command with quoted strings: "git commit -m 'fix: bug in parser'"
        - Classify git commands (all subcommands)
        - Classify npm/pip/cargo commands
        - Classify unknown command with LLM fallback
        - Integration with ToolClassifier (Bash tool -> BashAnalyzer)

# =============================================================================
# IMPLEMENTATION PLAN
# =============================================================================

implementation:
  file_to_create: "graphiti_core/session_tracking/bash_analyzer.py"
  test_file: "tests/unit/session_tracking/test_bash_analyzer.py"

  new_classes:
    - name: "BashCommandClassification"
      purpose: "Classification result for a bash command"
      base_class: "pydantic.BaseModel"
      fields:
        - name: "raw_command"
          type: "str"
          description: "Original command string"
        - name: "base_command"
          type: "str"
          description: "Primary executable (pytest, git, npm)"
        - name: "subcommand"
          type: "str | None"
          description: "Subcommand if applicable (install, commit)"
        - name: "flags"
          type: "list[str]"
          description: "Command flags and options"
        - name: "targets"
          type: "list[str]"
          description: "Command targets/arguments"
        - name: "intent"
          type: "ToolIntent"
          description: "Detected intent"
        - name: "domain"
          type: "ToolDomain"
          description: "Detected domain"
        - name: "confidence"
          type: "float"
          description: "0.0-1.0 confidence score"
          constraints: "ge=0.0, le=1.0"
        - name: "reasoning"
          type: "str"
          description: "Classification explanation"
        - name: "activity_signals"
          type: "dict[str, float]"
          description: "Activity vector contributions"
        - name: "method"
          type: "Literal['heuristic', 'llm', 'cached']"
          description: "Classification method used"
          default: "heuristic"

    - name: "LLMBashClassificationResponse"
      purpose: "Pydantic model for LLM structured response"
      base_class: "pydantic.BaseModel"
      fields:
        - name: "intent"
          type: "str"
          description: "Intent enum value"
        - name: "domain"
          type: "str"
          description: "Domain enum value"
        - name: "activity_signals"
          type: "dict[str, float]"
          description: "Activity vector contributions"
        - name: "reasoning"
          type: "str"
          description: "Classification explanation"

    - name: "BashAnalyzer"
      purpose: "Analyze and classify bash commands"
      methods:
        - name: "__init__"
          signature: "(self, llm_client: LLMClient | None = None, cache_path: Path | None = None)"
          purpose: "Initialize analyzer with optional LLM client and cache"

        - name: "classify"
          signature: "(self, command: str) -> BashCommandClassification"
          purpose: "Classify a single bash command"
          implementation: |
            1. Parse command into (base_command, subcommand, flags, targets)
            2. Try heuristic classification
            3. If confidence < 0.7, queue for LLM
            4. Return BashCommandClassification

        - name: "classify_batch"
          signature: "async (self, commands: list[str]) -> list[BashCommandClassification]"
          purpose: "Classify multiple bash commands with LLM batching"

        - name: "_parse_command"
          signature: "(self, command: str) -> tuple[str, str | None, list[str], list[str]]"
          purpose: "Parse command into base_command, subcommand, flags, targets"
          implementation: |
            1. Use shlex.split() for proper quote handling
            2. First token = base_command
            3. Subsequent tokens starting with '-' = flags
            4. Check if second token is a known subcommand
            5. Remaining tokens = targets

            Handle edge cases:
            - Quoted strings: "git commit -m 'fix: bug'"
            - Chained commands: "cd /foo && make"
            - Pipes: "cat file | grep pattern" (analyze first command)

        - name: "_classify_heuristic"
          signature: "(self, base_command: str, subcommand: str | None, flags: list[str], targets: list[str]) -> BashCommandClassification | None"
          purpose: "Classify using heuristic patterns"

        - name: "_classify_with_llm"
          signature: "async (self, commands: list[tuple[str, str, str | None, list[str], list[str]]]) -> list[BashCommandClassification]"
          purpose: "Classify unknown commands using LLM"

        - name: "_compute_activity_signals"
          signature: "(self, intent: ToolIntent, domain: ToolDomain) -> dict[str, float]"
          purpose: "Compute activity signals from intent and domain"
          implementation: "Reuse pattern from ToolClassifier.INTENT_TO_ACTIVITY and DOMAIN_MODIFIERS"

  constants:
    - name: "COMMAND_HEURISTICS"
      type: "dict[str, CommandHeuristic]"
      description: "Mapping of base commands to classification heuristics"

    - name: "LLM_BASH_CLASSIFICATION_PROMPT"
      type: "str"
      description: "Prompt template for LLM bash classification"

# =============================================================================
# TESTING PLAN
# =============================================================================

testing:
  unit_tests:
    - test_class: "TestCommandParsing"
      tests:
        - name: "test_parse_simple_command"
          input: "pytest tests/"
          expected: ("pytest", None, [], ["tests/"])

        - name: "test_parse_command_with_flags"
          input: "pytest -v --cov=src tests/"
          expected: ("pytest", None, ["-v", "--cov=src"], ["tests/"])

        - name: "test_parse_command_with_subcommand"
          input: "git commit -m 'message'"
          expected: ("git", "commit", ["-m", "message"], [])

        - name: "test_parse_docker_command"
          input: "docker run -d -p 8080:80 nginx"
          expected: ("docker", "run", ["-d", "-p", "8080:80"], ["nginx"])

        - name: "test_parse_complex_flags"
          input: "npm install --save-dev typescript"
          expected: ("npm", "install", ["--save-dev"], ["typescript"])

        - name: "test_parse_quoted_args"
          input: "git commit -m 'fix: handle edge case'"
          expected: ("git", "commit", ["-m", "fix: handle edge case"], [])

        - name: "test_parse_chained_command"
          input: "cd /foo && make test"
          expected: ("cd", None, [], ["/foo"])  # Only first command

    - test_class: "TestHeuristicClassification"
      tests:
        - name: "test_classify_git_commit"
          input: "git commit -m 'feat: new feature'"
          expected_intent: ToolIntent.CREATE
          expected_domain: ToolDomain.VERSION_CONTROL

        - name: "test_classify_npm_install"
          input: "npm install lodash"
          expected_intent: ToolIntent.CONFIGURE
          expected_domain: ToolDomain.PACKAGE

        - name: "test_classify_pytest"
          input: "pytest tests/ -v"
          expected_intent: ToolIntent.VALIDATE
          expected_domain: ToolDomain.TESTING

        - name: "test_classify_docker_run"
          input: "docker run -d nginx"
          expected_intent: ToolIntent.EXECUTE
          expected_domain: ToolDomain.PROCESS

        - name: "test_classify_pip_install"
          input: "pip install requests"
          expected_intent: ToolIntent.CONFIGURE
          expected_domain: ToolDomain.PACKAGE

        - name: "test_classify_cargo_build"
          input: "cargo build --release"
          expected_intent: ToolIntent.CREATE
          expected_domain: ToolDomain.CODE

    - test_class: "TestActivitySignals"
      tests:
        - name: "test_git_commit_signals"
          description: "git commit should boost building"
          expected_signals: {"building": 0.6}

        - name: "test_pytest_signals"
          description: "pytest should boost testing"
          expected_signals: {"testing": 0.9}

        - name: "test_npm_install_signals"
          description: "npm install should boost configuring"
          expected_signals: {"configuring": 0.7}

    - test_class: "TestLLMFallback"
      tests:
        - name: "test_unknown_command_uses_llm"
          description: "Unknown commands should fall back to LLM"

        - name: "test_llm_response_parsing"
          description: "LLM response should parse to BashCommandClassification"

        - name: "test_llm_error_fallback"
          description: "LLM errors should return low-confidence default"

  integration_tests:
    - test_class: "TestBashAnalyzerIntegration"
      tests:
        - name: "test_with_tool_classifier"
          description: "BashAnalyzer integrates with ToolClassifier for Bash tool"

        - name: "test_cache_persistence"
          description: "Classifications are cached and persisted"

# =============================================================================
# IMPLEMENTATION ORDER
# =============================================================================

implementation_order:
  phase_i:
    description: "Core models and parsing"
    tasks:
      - "Create bash_analyzer.py with imports"
      - "Implement BashCommandClassification model"
      - "Implement LLMBashClassificationResponse model"
      - "Implement _parse_command() with shlex"

  phase_ii:
    description: "Heuristic classification"
    tasks:
      - "Define COMMAND_HEURISTICS constant"
      - "Implement _classify_heuristic() method"
      - "Implement _compute_activity_signals() method"
      - "Implement classify() method (heuristic-only first)"

  phase_iii:
    description: "LLM fallback"
    tasks:
      - "Define LLM_BASH_CLASSIFICATION_PROMPT constant"
      - "Implement _classify_with_llm() async method"
      - "Update classify() to use LLM fallback"
      - "Implement classify_batch() for efficiency"

  phase_iv:
    description: "Caching (optional - can reuse ToolClassifier pattern)"
    tasks:
      - "Add cache_path parameter to __init__"
      - "Implement cache key generation for commands"
      - "Add cache lookup in classify()"

  phase_t:
    description: "Testing"
    tasks:
      - "Write unit tests for command parsing"
      - "Write unit tests for heuristic classification"
      - "Write unit tests for activity signals"
      - "Write integration tests with mock LLM"

# =============================================================================
# DEPENDENCIES AND IMPORTS
# =============================================================================

new_imports:
  - "import shlex"
  - "import logging"
  - "from pathlib import Path"
  - "from typing import ClassVar, Literal"
  - "from pydantic import BaseModel, Field"
  - "from graphiti_core.session_tracking.tool_classifier import ToolIntent, ToolDomain"
  - "from graphiti_core.llm_client import LLMClient"

# =============================================================================
# INTEGRATION POINTS
# =============================================================================

integration:
  story_7_unified_classifier:
    description: "Unified Tool Classifier (Story 7) will integrate BashAnalyzer"
    interface: |
      When ToolClassifier receives a Bash tool call:
      1. Extract command string from parameters["command"]
      2. Call BashAnalyzer.classify(command)
      3. Merge BashCommandClassification into ToolClassification

  tool_classifier_modification:
    description: "ToolClassifier.classify() may need minor update for Bash tool"
    implementation: |
      In ToolClassifier.classify():
      if tool_name == "Bash" and parameters and "command" in parameters:
          bash_result = self._bash_analyzer.classify(parameters["command"])
          # Enrich base classification with bash-specific details

# =============================================================================
# RISKS AND MITIGATIONS
# =============================================================================

risks:
  - risk: "Command parsing edge cases (complex quoting, escapes)"
    mitigation: "Use shlex.split() which handles most shell quoting; add explicit test cases"

  - risk: "Unknown commands may not classify accurately"
    mitigation: "LLM fallback with good prompt; low confidence score for uncertainty"

  - risk: "Performance for many bash commands"
    mitigation: "Batch LLM calls; cache classifications by command pattern"

  - risk: "Shell-specific syntax variations (bash vs zsh vs fish)"
    mitigation: "Focus on common POSIX-like commands; document limitations"

# =============================================================================
# ACCEPTANCE CRITERIA MAPPING
# =============================================================================

ac_mapping:
  "AC-1": ["BashCommandClassification model"]
  "AC-2": ["BashAnalyzer.classify()", "_parse_command()"]
  "AC-3": ["COMMAND_HEURISTICS", "_classify_heuristic()"]
  "AC-4": ["_classify_with_llm()", "LLM_BASH_CLASSIFICATION_PROMPT"]
  "AC-5": ["TestCommandParsing", "TestHeuristicClassification", "TestLLMFallback"]
